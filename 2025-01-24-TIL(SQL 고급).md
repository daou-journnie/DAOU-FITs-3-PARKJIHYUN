# WITH

SQL에서 Common Table Expression(CTE)를 정의하기 위한 구문으로 서브쿼리를 재사용 가능하고 가독성 높게 작성할 수 있도록 지원

- 복잡한 SQL 쿼리를 읽기 쉽고 관리 가능하게 구조화
- 동일한 서브 쿼리를 반복적으로 재작성 하지 않아도 됨
- 재귀 쿼리 작성 시 활용

## CTE

- CTE는 임시적으로 데이터를 메모리에 저장하여 처리 → PGA 이용
- PGA 부족 →Temp Tablespace공간 사용
- CTE의 결과를 도출하는 데 복잡한 계산이 이루어져야하고 데이터량도 많은 경우에는 초기 비용이 들더라도 Temp 영역에 저장해 두는 것이 유리할 수 있음
- 데이터량이 적고 결과 도출 비용이 크지 않을 경우 Temp영역 저장 비용이 더 커버릴 가능성 존재 (PGA로 해결 되는지 확인 필요)

### 단일 CTE

```sql
WITH DEPARTMENT_SALARY AS (
	SELECT DEPARTMENT_ID, ROUND(AVG(SALARY),2) AS AVG_SALARY
	FROM EMPLOYEES
	GROUP BY DEPARTMENT_ID
	ORDER BY DEPARTMENT_ID NULLS LAST)
	
SELECT *
FROM DEPARTMENT_SALARY 
WHERE AVG_SALARY>5000
;
```

### 다중 CTE

```sql
WITH
  cte1 AS (SELECT a, b FROM table1),
  cte2 AS (SELECT c, d FROM table2)
SELECT b, d FROM cte1 JOIN cte2
WHERE cte1.a = cte2.c;
```

### 재귀 CTE

```sql
WITH RECURSIVE cte (n) AS
(
  SELECT 1
  UNION ALL
  SELECT n + 1 FROM cte WHERE n < 5
)
SELECT * FROM cte;
```

```sql
WITH NUMBERS (NUM) AS (
	SELECT 1 AS NUM
	FROM DUAL
	UNION ALL
	SELECT NUM+1 AS NUM
	FROM NUMBERS
	WHERE NUM < 10
)
SELECT B.NUM
FROM NUMBERS B;
```

### Temp Tablespace 사용 확인

- 데이터 정렬 작업에서 메모리를 다 사용하면 Temp Tablespace에 데이터 기록
- 실행 계획에서 SORT (GROUP BY), SORT (ORDER BY), SORT (UNIQUE) 같은 키워드로 나타남

# JOIN 최적화

## Nested Loop Join

- 중첩 for문과 유사한 형태
- driving 테이블의 처리 범위에 의해 전체 일량이 결정
- join컬럼이 driven 테이블에 index로 설정 되어 있어야 유리
- OLTP성 쿼리에 적합
- 힌트 `/*+ ordered use_nl */`로 nested loop join 강제할 수 있음 to 옵티마이저

드라이빙과 드리븐 테이블 생각하기!!!!

Join 순서 튜닝(filter 조건 없을 때)

```sql
Index: grade_code(grade_info)

SELECT /*+ordered use_nl(g)*/
				g.grade_name, c.*
FROM customers c, grade_info g
WHERE c.grade_code=g.grade_code;				
```

customers(1M) → index:grade_code(1M) → grade(3)  
⇒ 2M access

```sql
Index: grade_code(customers)

SELECT /*+ordered use_nl(g)*/
				g.grade_name, c.*
FROM grade_info g, customers c
WHERE c.grade_code=g.grade_code;			
```

grade(3) → index:grade_code(1M) → customers(1M)	
⇒ 1M 3 access

필터 조건 있는 경우

```sql
Index: grade_code(grade_info)
				birthyear(customers)

SELECT /*+ordered use_nl(g)*/
				g.grade_name, c.*
FROM customers c, grade_info g
WHERE c.grade_code=g.grade_code
		AND c.birthyear = '2002';			
```

얘는 30만번

```sql
Index: grade_code+
				birthyear(customers)

SELECT /*+ordered use_nl(g)*/
				g.grade_name, c.*
FROM grade_info g, customers c
WHERE c.grade_code=g.grade_code
		AND c.birthyear = '2002';			
```

grade(3) → index:grade_code+birthyear(100K) → customers(1M)	
⇒ 100K 3 accesses

## Hash Join

- Join 컬럼에 인덱스가 없어 NL Join이 효과적이지 못한 상황에 대한 대안
- Join 컬럼에 인덱스가 있지만 driving table에서 driven table로의 엑세스량이 많아 Random Access 부하가 심한 경우
- 두 테이블 중 작은 테이블을 메모리에 생성
- 큰 테이블이 driving 테이블이 되어 join 데이터의 hash 값을 메모리의 hash값과 비교, 동일한 레코드를 결과 목록에 추가
- Table Random Access 부하가 없음
- 수행빈도가 낮고 시간이 오래 걸리는 OLAP성 쿼리에 적합
- Hash Function: 임의의 데이터를 고정된 길이의 데이터로 매핑하는 함수
- driving table → probe input
- driven table(in-memory) → build input

### 33

- Hash Join의 빠른 속도 때문에 Join을 Hash Join으로 처리하려는 유혹 존재
- Index는 한 번 생성해 놓으면 계속해서 사용할 수 있는 영구적인 오브젝트인 반면 Hash Table은 단 하나의 쿼리를 위해 생성하고 Join이 끝나면 바로 소멸하는 자료구조
- 수행시간이 짧으면서 수행빈도가 매우 높은 OLTP성 쿼리를 Hash Join으로 처리한다면 CPU와 메모리 사용률 크게 증가
- 수행빈도가 낮고 쿼리 수행 시간이 오래 걸리는 대용량 테이블을 Join 할 때 사용

# 실행계획

SQL로 요청한 데이터를 어떻게 꺼내 올 것인가에 대한 PLAN

- 성능 병목 현상을 파악하는 데 유용
- 높은 확률로 Optimizer가 결정한 실행 계획이 최선인 경우가 많음
    - 아니라면 Hint를 사용해서 튜닝

```sql
EXPLAIN PLAN FOR
SELECT * FROM EMPLOYEES;
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
```

- `ALTER SESSION SET STATISTICS_LEVEL=ALL;`

실제 데이터로 보여줌

⇒ 패치가 다 돼야함? 스크롤 다 내려야한다는 거??

```sql
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'ALLSTATS LAST'));

--
SQL_ID  97qtbqudbrxr5, child number 0
-------------------------------------
select * from v$version where banner like '%Oracle%'
 
Plan hash value: 1078166315
 
-----------------------------------------------
| Id  | Operation        | Name      | E-Rows |
-----------------------------------------------
|   0 | SELECT STATEMENT |           |        |
|*  1 |  FIXED TABLE FULL| X$VERSION |      1 |
-----------------------------------------------
 
Predicate Information (identified by operation id):
---------------------------------------------------
 
   1 - filter(("BANNER" LIKE '%Oracle%' AND "BANNER" IS NOT NULL AND 
              INTERNAL_FUNCTION("CON_ID") AND "INST_ID"=USERENV('INSTANCE')))
 
Note
-----
   - Warning: basic plan statistics not available. These are only collected when:
       * hint 'gather_plan_statistics' is used for the statement or
       * parameter 'statistics_level' is set to 'ALL', at session or system level
 
```

- Operation
    
    작업 유형
    
- Name
    
    테이블 또는 인덱스 이름
    
- E-Rows
    
    옵티마이저가 예측한 Row수
    
- A-Rows
- Buffers
    
    해당 단계에서 I/O한 Block 수
    
    - 

<aside>
✨

- 버퍼 작게 만들기가 목표
- 들여쓰기 제일 많은 것부터 읽어야함
</aside>

### Access 조건

- 인덱스나 테이블에 접근할 때 사용하는 조건, 검색 제한
- 데이터 액세스를 효율적으로 제한하여 불필요한 I/O를 줄임

### Filter 조건

- 데이터를 반환한 후 추가적으로 필터링하는 조건
- Access조건보다 덜 효율적

## 분석

- TABLE ACCESS FULL
    
    테이블 모든 행 스캔
    
- TABLE ACCESS BY INDEX ROWID
    
    인덱스를 통해 식별된 행(ROW ID)을 기반으로 테이블 데이터 읽는 작업
    
- INDEX RANGE SCAN
    
    범위 조건에 따라 인덱스를 검색하는 작업
    
- INDEX UNIQUE SCAN
    
    고유 인덱스를 사용하여 단일 행을 검색하는 작업
    
- NESTED LOOPS
    
    중첩 반복을 사용해 두 소스를 결합
    
- HASH JOIN
    
    해시 알고리즘을 사용하여 데이터 결합
    
- SORT AGGREGATE
    
    집계함수를 계산하기 위한 작업
    
    GROUP BY 없이 집계함수가 실행될 때 사용
    
    데이터 정렬 안하고 집계 연산만 수행
    
- SORT GROUP BY
    
    그룹바이 조건 처리하려고 데이터 정렬
    
- SORT ORDER BY
    
    데이터 정렬하는 작업
    
    메모리 또는 임시 테이블 공간을 사용하여 데이터 정렬
    
    정렬 작업 비용이 많이 드는 경우 적절한 인덱스 활용
    
- HASH GROUP BY
    
    해시 알고리즘 어쩌구
    
- VIEW PUSHED PREDICATE
    
    WHERE조건을 VIEW안으로 밀어넣어서 조인 범위 줄임
    
    쿼리에서 뷰 사용시 필터 조건을 뷰 내부로 이동시켜 처리 성능 높임
    
- MATERIALIZE
    
    뷰나 서브쿼리 결과를 메모리에 임시로 저장하는 작업
    
- WINDOW SORT
    
    윈도우 함수를 처리하기 위한 정렬 작업
    

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/93168b73-e0b5-48df-bb63-8f8bf0a550fe/b0ecfeb6-7bba-451d-97ea-500beaa733f0/image.png)

시스템 계정으로 만들어서

새로운 사용자 만들기

```sql
CREATE USER c##user IDENTIFIED BY 1234;
grant connect, resource, dba to c##user;
```

# 사용자 정의 함수

사용자가 특정 작업을 수행하기 위해 정의한 PL/SQL 코드 블록

- 주로 입력값을 받아 처리 후 결과를 반환
- 특정 작업을 수행한 후 값 반환
- 재사용 가능
    - 반복적인 작업을 자동화하고 코드 재사용성을 높이기 위해 사용
- SQL문에서 호출 가능
- 복잡한 논리를 캡슐화하여 유지보수 용이

### 구성요소

- **함수 이름**: 함수 호출 시 사용할 이름.
- **매개변수(Parameter)**: 함수에 전달할 입력값.
- **반환값(Return Value)**: 함수가 처리한 결과로 반환하는 값.
- **PL/SQL 코드 블록**: 함수 내부에서 실행되는 논리.

```sql
CREATE OR REPLACE FUNCTION func_name (parameter IN data_type)
RETURN return_type IS
BEGIN
	--
	RETURN result;
END;

--
CREATE OR REPLACE FUNCTION get_discount_price(price IN NUMBER)
RETURN NUMBER IS
    discounted_price NUMBER;
BEGIN
    discounted_price := price * 0.9; -- 10% 할인
    RETURN discounted_price;
END;

```

함수 호출

```sql
-- SQL 문에서 호출
SELECT get_discount_price(1000) AS discounted_price FROM dual;

-- PL/SQL 블록에서 호출
DECLARE discounted_price NUMBER;
BEGIN
	discounted_price := get_discount_price(1000);
	DBMS_OUTPUT.PUT_LINE('할인가:'||discounted_price);
END;
```

### 오류처리

사용자 정의 함수에서 오류 발생하면 EXECPTION 구문으로 처리 가능

프로시저를 만들어놓으면 마이바티스 안에서도 콜 할 수 있다?

단점

- 복잡성
- 디버깅 어려움
- 의존성 문제

보완

- 권한 제한: 함수 생성 및 실행 권한을 관리해야함
- SQL Injection: 매개변수 값을 안전하게 처리
- 데이터 무결성: 함수가 데이터 무결성을 해치지 않도록 설계

# REDO/UNDO

데이터 무결성과 복구 기능 제공

### REDO

데이터베이스의 변경 내용을 복구하기 위한 로그

변경 내용 재생(재적용)

- 데이터베이스가 비정상 적으로 종료되었을 때 복구
- 커밋된 트랜잭션 변경 내용을 재생하여 데이터 변경 전 상태 조회 가능
- REDO 로그는 디스크에 지속적으로 기록됨

### UNDO

데이터 변경 이전 상태를 저장하여 롤백하거나 트랜잭션을 취소할 수 있게 함

변경 내용 취소 (원래 상태 복구)

- 트랜잭션 롤백 시 변경 내용을 원래 상태로 복구
- 읽기 일관성을 제공하여 다른 세션이 데이터 변경 전 상태를 조회 가능
- 복구 또는 취소 작업을 위해 UNDO 세그먼트 사용

# SQL Injection

공격자가 입력 필드나 URL에 악의적인 SQL 코드를 삽입하여 데이터베이스를 조작하는 공격 기법

`#{    }`

- 바인드 변수로 처리해서 앞 쿼리가 동일하다면 소프트파싱이 가능해짐
- PREPARED STATEMENT
