# 서브쿼리

> SQL문 안에 포함된 또 다른 SQL 문
> 
- 메인 쿼리에 값을 제공하거나 조건 지정

## 연관 여부

### 비연관 서브쿼리 (Non-correlated Subquery)

서브쿼리가 독립적으로 실행되어 결과 반환

- 메인 쿼리와 서브 쿼리 간 상호작용 없음
    - 서브쿼리만으로 에러없이 돌아가냐

```sql
-- 평균 급여보다 높은 급여를 받는 직원 조회
SELECT NAME
FROM EMPLOYEES
WHERE SALARY > (SELECT AVG(SALARY) FROM EMPLOYEES);
```

`SELECT AVG(SALARY) FROM EMPLOYEES`

- **단일값**이기 때문에 단일 연산자임

### 연관 서브쿼리 (Correlated Subquery)

서브쿼리가 메인 쿼리의 각 행마다 실행

- 메인 쿼리의 데이터를 서브쿼리에서 참조
    - 혼자 돌리면 에러남

```sql
-- 동일 부서 안에서 돈 제일 많이 받는 사람
SELECT NAME 
FROM EMPLOYEES E1
WHERE SALARY = (SELECT MAX(SALARY)
								FROM EMPLOYEES E2
								WHERE E1.DEPARTMENT_ID = E2.DEPARTMENT_ID)
```

## 위치

### 스칼라 서브쿼리 (Scalar Subquery)

하나의 값(스칼라 값)을 반환하는 서브쿼리

 `SELECT`절에서 사용

- 주로 집계 값이나 계산 결과를 포함할 때 활용

```sql
-- 각 직원의 급여와 해당 부서 평균 급여 조회
SELECT NAME, SALARY, (SELECT AVG(SALARY) FROM EMPLOYEES 
											WHERE DEPARTMENT_ID = E.DEPARTMENT_ID) AS AVG SALARY
FROM EMPLOYEES E;
											
```

<aside>
✨

### JOIN과 서브쿼리(특히 스칼라 서브쿼리) 비교 정리

1. **JOIN과 서브쿼리의 선택**
    - 일반적으로 JOIN과 서브쿼리는 동일한 결과를 낼 수 있지만, 사용 상황과 목적에 따라 적합한 방법이 다를 수 있음.
    - 성능 차이는 데이터베이스 엔진의 최적화 방식에 따라 대부분 크지 않음.
2. **스칼라 서브쿼리 캐싱 기능**:
    
    동일한 입력에 대해 스칼라 서브쿼리의 결과를 한 번 계산한 후, 이를 저장하여 이후에 동일한 입력이 등장했을 때 재계산하지 않고 저장된 값을 사용하는 기법
    
    ⇒ 동일한 값에 대해 중복 계산을 방지함.
    
    - 캐싱 덕분에 공통 서브쿼리를 여러 번 참조해도 효율적으로 작동.
    - **적용 예시**:
        - 자주 사용되는 소규모 데이터 집합을 효율적으로 조회해야 할 때.
3. **UNNEST (서브쿼리를 JOIN으로 변환)**
    - 데이터베이스 엔진은 서브쿼리를 JOIN으로 변환(UNNEST)하여 최적화된 실행 계획을 생성하기도 함.
    - 이러한 변환은 대량 데이터 처리에 적합하며, 특정 상황에서는 JOIN이 더 나은 성능을 보일 수 있음.
4. **스칼라 서브쿼리 활용 팁**
    - 반복적으로 참조되는 작은 데이터는 스칼라 서브쿼리로 캐싱하면 효율적.
    - 하지만 데이터가 많거나 복잡한 서브쿼리는 캐싱 비용이 높아질 수 있으므로 주의.

---

### 예시

### 1. **JOIN**

```sql
SELECT e.employee_id, e.name, d.department_name
FROM employees e
JOIN departments d ON e.department_id = d.department_id;

```

- 여러 테이블 간의 관계를 활용하여 데이터를 조합.

### 2. **스칼라 서브쿼리**

```sql
SELECT e.employee_id, e.name,
       (SELECT department_name
        FROM departments d
        WHERE d.department_id = e.department_id) AS department_name
FROM employees e;

```

- `e.department_id` 값이 `101`인 첫 번째 행을 처리할 때 서브쿼리가 실행되고, 결과 값(예: 'Sales')이 캐싱됩니다.
- 이후 `e.department_id = 101`인 행이 또 나올 경우, 서브쿼리를 재실행하지 않고 캐싱된 'Sales' 값을 사용합니다.

---

- **작은 데이터 범위**: 스칼라 서브쿼리는 입력 값의 범위가 작을수록 캐싱 효과가 큽니다.
- **반복 참조가 많은 쿼리**: 동일한 값을 여러 번 참조하는 경우, 스칼라 서브쿼리가 효율적입니다.
</aside>

### 인라인 뷰 (Inline View)

`FROM`절에서 서브쿼리 결과를 테이블처럼 사용

- 별칭붙여서 활용 가능

```sql
-- 부서별 평균 급여를 계산하고 각 부서의 이름과 평균 급여 조회
SELECT D.DEPARTMENT_NAME, T.AVG_SALARY
FROM DEPARTMENTS D,
			(SELECT DEPARTMENT_ID, AVG(SALARY) AS AVG_SALARY
				FROM EMPLOYEES
				GROUP BY DEPARTMENT_ID) T
WHERE D.DEPARTMENT_ID = T.DEPARTMENT_ID
```

- 서브쿼리에서 그룹바이

### 중첩 서브쿼리 (Nested Subquery)

`WHERE`절에서 조건 설정위해 사용

- 서브쿼리 결과에 따라 메인 쿼리의 필터링 결정
    
    ```sql
    -- 특정 부서에 속한 직원 조회
    SELECT NAME
    FROM EMPLOYEES
    WHERE DEPARTMENT_ID = (SELECT DEPARTMENT_ID
    												FROM DEPARTMENTS
    												WHERE DEPARTMENT_NAME = '')	
    ```
    
- `HAVING` 절에서 조건 설정하기 위해 집계 함수와 사용
    
    ```sql
    -- 평균급여 이상인 부서의 총 급여 조회
    SELECT DEPARTMENT_ID, SUM(SALARY) AS TOTAL_SALARY
    FROM EMPLOYEES
    GROUP BY DEPARTMENT_ID
    HAVING SUM(SALARY) > (SELECT AVG(SUM(SALARY))
    											FROM EMPLOYEES
    											GROUP BY DEPARTMENT_ID);
    ```
    

 

## 반환값 유형

### 단일행 (Single-row Subquery)

서브쿼리가 단일 행과 단일 열을 반환

- 비교 연산자와 함께 사용
    - =, <, > …
- 스칼라 서브쿼리 - 컬럼 대용으로 씀
- `WHERE ROWNUM = 1`  단일행 보장 - 중요한 경우 사용

```sql
-- 가장 높은 급여를 받는 직원 조회
SELECT NAME
FROM EMPLOYEES
WHERE SALARY = (SELECT MAX(SALARY) FROM EMPLOYEES);
```

 

### 다중행 (Multi-row Subquery)

서브쿼리가 여러 행 반환

- 다중 행 연산자와 함께 사용
    - IN, ANY, ALL

```sql
-- 특정 부서들에 속한 직원 조회
SELECT NAME
FROM EMPLOYEES
WHERE DEPARTMENT_ID IN (SELECT DEPARTMENT_ID
													FROM DEPARTMENTS
													WHERE LOCATION='New York');
```

### 다중열 (Multi-column Subquery)

서브쿼리가 여러 열을 반환

- 메인 쿼리의 여러 열과 비교 가능

```sql
-- 특정 부서와 직무를 가진 직원 조회
SELECT NAME
FROM EMPLOYEES
WHERE (DEPARTMENT_ID, JOB_ID) IN (SELECT DEPARTMENT_ID, JOB_ID
																	FROM JOB_HISTORY);
```

## 유의 사항

- 성능 최적화
    - 비연관 서브쿼리는 독립적이므로 더 바름
    - 연관 서브쿼리는 메인 쿼리의 각 행마다 실행되무로 성능 저하 가능
- 적절한 반환값 확인
    - 서브쿼리가 반환하는 값의 유형(단일, 다중값)에 따라 연산자 선택이 중요
- JOIN 대체 가능성
    - 일부 서브쿼리는 JOIN으로 대체할 수 있어 성능 개선 가능
        - **테이블 간의 관계가 명확**하고, 대량 데이터를 처리해야 하는 경우.
        - 결과 집합을 효율적으로 조합해야 하는 경우.
        - 동일한 데이터를 여러 번 참조해야 하는 경우.

ORACLE 힌트

Optimizer의 판단이 마음에 들지 않을때, 오라클 힌트를 써서 내가 원하는 방향으로 강제할 수 있음

## 예제

- 가장 많은 잔액을 가진 계좌의 잔액과 계좌 id조회
    
    ```sql
    SELECT ACCOUNT_ID, BALANCE
    FROM ACCOUNTS
    WHERE BALANCE = (SELECT MAX(BALANCE) FROM ACCOUNTS);
    
    -- 나중에 window 함수 등으로 더 개선할 수 있는 코드
    
    SELECT ACCOUNT_ID, BALANCE
    FROM (
        SELECT ACCOUNT_ID, BALANCE, 
               RANK() OVER (ORDER BY BALANCE DESC) AS rank
        FROM ACCOUNTS
    ) ranked_accounts
    WHERE rank = 1;
    
    SELECT ACCOUNT_ID, BALANCE
    FROM (
        SELECT ACCOUNT_ID, BALANCE, 
               ROW_NUMBER() OVER (ORDER BY BALANCE DESC) AS row_num
        FROM ACCOUNTS
    ) ranked_accounts
    WHERE row_num = 1;
    
    ```
    
- 가장 최근에 가입한 고객의 이름과 가입 날짜 조회
    
    ```sql
    SELECT NAME, CREATED_AT
    FROM CUSTOMERS
    WHERE CREATED_AT = (SELECT MAX(CREATED_AT) FROM CUSTOMERS));
    ```
    
    - 최근 - MAX
- 잔액이 평균 잔액보다 높은 계좌
    
    ```sql
    SELECT ACCOUNT_ID, BALANCE
    FROM ACCOUNTS
    WHERE BALANCE > (SELECT AVG(BALANCE) FROM ACCOUNTS);
    
    -- WINDOW FUNC
    SELECT ACCOUNT_ID, BALANCE
    FROM (
        SELECT ACCOUNT_ID, BALANCE, 
               AVG(BALANCE) OVER () AS avg_balance
        FROM ACCOUNTS
    ) subquery
    WHERE BALANCE > avg_balance;
    
    ```
    
    얘도 개선 가능
    
- 각 지점에서 대출 금액이 가장 높은 대출 조회
    
    ```sql
    SELECT BRANCH_ID, LOAN_ID, AMOUNT
    FROM LOANS L1
    WHERE (SELECT MAX(AMOUNT)
    FROM LOANS L2
    WHERE L1.BRANCH_ID = L2.BRANCH_ID)
    ```
    
- 각 계좌 거래 중에서 가장 큰 거래 금액 조회

# 집합연산자

ALIAS는 맨 처음 SELECT 절을 따름

ORDER BY는 최종 결과에만 적용 가능

MINUS, INTERCET같은 거 쓸때는 마지막에 몇줄 나오는 지. 

### UNION

두 SELECT 결과를 합치되 중복 제거

- 자동 정렬 됨

```sql
SELECT *column_name* FROM *table1*
UNION
SELECT *column_name* FROM *table2*;

-- 
SELECT *column_name* FROM *table1*
UNION
SELECT *column_name* FROM *table2*;
```

테이블 1, 2의 속성의 타입이 같아야함

ORDER BY는 맨 아래 한 번만 쓸 수 있음

### UNION ALL

두 SELECT 결과를 합치되 중복 포함

- 결과는 정렬되지 않음
- 웬만하면 이거 쓰는 게 좋음

```sql
SELECT *column_name* FROM *table1*
UNION ALL
SELECT *column_name* FROM *table2*;
```

### INTERSECT

두 SELECT 결과의 교집합

- 중복된 행은 하나만 반환

```sql
SELECT *column_name* FROM *table1*
INTERSECT
SELECT *column_name* FROM *table2*;

-- 대출한 고객
SELECT CUSTOMER_ID FROM CUSTOMERS
INTERSECT
SELECT CUSTOMER_ID FROM LOANS;
```

### MINUS

첫 번째 SELECT 결과에서 두 번째 SELECT 결과를 뺀 차집합

- 중복된 행은 하나만 반환
  ```sql
SELECT *column_name* FROM *table1*
MINUS
SELECT *column_name* FROM *table2*;
```
