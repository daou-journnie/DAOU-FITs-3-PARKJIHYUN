# Java

## 독립적 언어

운영체제에 독립적임

- **컴파일 및 실행 과정**
    
       `.java`  —(javac compiler)→  bytecode (`.class`)  —(JVM)→  machine code
    
    - **소스 코드**(`.java`)는 컴파일을 통해 플랫폼 독립적인 **bytecode**(`.class`)로 변환
    - 이 **bytecode**는 **JVM**에서 읽혀 각 운영체제에 맞는 **machine code**로 변환되어 실행
    - 바이트 코드는 클래스 단위로 컴파일

## 객체 지향적 언어

현실 세계의 문제를 **객체** 단위로 모델링하여 표현

↔  **절차적 언어**(예: C)와 비교

- **절차적 접근**: 프로그램을 기능별 함수로 세분화하여 구현
- **장점**
    - 요구사항 분석이 용이
    - 설계 및 구현이 단순함
    - 비용 절감 효과
- **단점**
    - 유지보수 및 확장에 어려움
- **논리적 비교**
    - 객체 지향적 접근: "실제 세계의 객체(상태와 행위의 집합)"로 문제를 해결
    - 절차적 접근: "함수의 집합"으로 문제를 해결

---

# Java 실행 환경 구성 요소

## JVM (Java Virtual Machine)

- bytecode를 읽고 실행하는 주체
- 플랫폼 독립성을 보장하는 핵심 요소
- 메모리 구조
    
    ![image.png](attachment:819ce95c-e0a8-4f1c-921b-f44bdb616422:image.png)
    
    ![image.png](attachment:3e5e0a30-c991-4da4-b669-d5bc173e7046:image.png)
    
    - 클래스 생성
        - Method Area에 클래스 정보 올림
    - 메인 메서드 실행
        - Stack에 올라감
            - local var.
                - primitive type - 변수에 값을 저장
                - reference type - 변수에 Heap에 생성된 주소값을 저장
            - static var.
                
                Method Area에 저장되고 main()이 실행되면 값이 저장됨
                

## JRE (Java Runtime Environment)

> **JVM** + **Java Class Library**
> 
- 자바 애플리케이션을 실행할 수 있는 환경 제공

## JDK (Java Development Kit)

> **JRE** + Utilities (예: `javac`, `java`, `javadoc` 등)
> 
- 자바 애플리케이션 개발 및 실행을 위한 전체 도구 세트 제공

---

# OOP (객체 지향 프로그래밍)

## 객체 모델링

현실 세계의 문제(예: 시계 등)를 프로그래밍적으로 **모델링**

### **Abstraction (추상화)**

- 문제의 구성 요소를 파악 후, 이를 **상태**와 **행위**로 분리하여 표현
    - 상태 → 변수 (field)
    - 행위 → 함수 (method)
- **논리 표현**
    - 상태(field) ∪ 행위(method) = 객체

## class

### 객체 모델링 수단

클래스는 **field**와 **method**의 집합으로, 현실의 객체를 모델링하는 단위

```java
class Customer {
    // fields: 상태
    String name;
    int age;

    // methods: 행위
    // (예: 구매, 문의 등의 기능 구현)
}

```

- **검토 포인트**:
    - "이 클래스가 객체 모델링에 적합한가?" 라는 의문을 항상 고려

### 인스턴스 생성 수단

클래스에 기술된 내용을 바탕으로 **저장공간**(인스턴스)이 생성되어 실제 프로그램 내에서 사용됨

### ADT (추상 데이터 타입)

클래스는 고정된 데이터 타입이 아니라, 개발자가 임의로 정의할 수 있는 **추상 데이터 타입 (ADT)**

- 데이터와 기능을 하나의 단위로 묶어 새로운 데이터 타입을 제공

## package

- 자바 프로그램은 여러 클래스의 집합이며, 이를 효율적으로 관리하기 위한 **논리적 구분**
- package는 실제 **물리적 폴더** 구조로 표현됨
- 클래스 선언 시 package를 명시하지 않으면 **unnamed package**에 포함됨

## Instance

class에 정의된 field와 method를 위해 확보한 공간 == object

## Constructor

> `new` 로 생성한 instance를 초기화
> 

`InstanceTest d = new InstanceTest();`

# Data Type

strong type language - 타입 명시

🖐🏻 ☝🏻 ✊🏻

## Primitive Type

value가 변수에 assign 됨

| Data Type | Description |  |
| --- | --- | --- |
| `byte` | Stores **whole numbers** from -128 to 127  | 1 byte |
| `short` | Stores whole numbers from -32,768 to 32,767 | 2 byte |
| `int` | Stores whole numbers from -2,147,483,648 to 2,147,483,647 | 4 byte |
| `long` | Stores whole numbers from -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807 | 8 byte
은행은행잔액 |
| `float` | Stores **fractional numbers**. Sufficient for storing 6 to 7 decimal digits |  |
| `double` | Stores fractional numbers. Sufficient for storing 15 to 16 decimal digits |  |
| `boolean` | Stores true or false values |  |
| `char` | Stores a single character/letter or ASCII values |  |

## Reference Type

class로 선언된 변수 지칭

변수에 메모리 주소(java는 해쉬값)을 저장

The main differences between **primitive** and **non-primitive** data types are:

- Primitive types in Java are predefined and built into the language, while non-primitive types are created by the programmer (except for `String`).
- Non-primitive types can be used to call methods to perform certain operations, whereas primitive types cannot.
- Primitive types start with a lowercase letter (like `int`), while non-primitive types typically starts with an uppercase letter (like `String`).
- Primitive types always hold a value, whereas non-primitive types can be `null`.

## Type Casting

### Implicit

converting a smaller type to a larger type size
`byte` → `short` → `char` → `int` → `long` → `float` → `double`

### Casting

converting a larger type to a smaller size type
`double` → `float` →→ `long` → `int` → `char` → `short` → `byte`
