# Sequence

자동으로 고유한 숫자를 생성하는 오라클 객체

주로 기본키나 고유 값이 필요한 컬럼에 사용

- 고유한 숫자 생성 보장
- 숫자 증감 방향 설정 가능
- START WITH, INCREMENT BY 등으로 생성 규칙 정의 가능
- CACHE 사용해서 성능 최적화 가능

```sql
CREATE SEQUENCE sequence_name
	START WITH initial_value
	INCREMENT BY step_value
	MAXVALUE maximum_Ovalue
	CYCLE|NOCYCLE
	CACHE|NOCACHE;
```

```sql
CREATE SEQUENCE EMPLOYEE_SEQ
START WITH 1
INCREMENT BY 1
MAXVALUE 9999999
NOCACHE;
```

```sql
SELECT EMPLOYEE_SEQ.NEXTVAL FROM DUAL;
SELECT EMPLOYEE_SEQ.CURRVAL FROM DUAL;
```

```sql
INSERT INTO EMPLOYEES(EMPLOYEE_ID, NAME)
VALUES (EMPLOYEE_SEQ.NEXTVAL+1000, 'HIHI');
```

```sql
SELECT SEQUENCE_NAME, LAST_NUMBER
FROM USER_SEQUENCES;
```

```sql
DROP SEQUENCE EMPLOYEE_DEQ;
```

# Index

데이터베이스 테이블의 검색 성능을 향상시키기 위해 사용되는 특별한 데이터 구조

인덱스를 걸 때 어떤 컬럼에 거는 게 효율적인가

- 쿼리 실행 시간 단축
    - 검색 성능 향상
        - SELECT 쿼리 실행시
- 테이블의 특정 컬럼을 기준으로 데이터 정렬 및 관리
    - 인덱스 사용하면 데이터가 자동으로 정렬
- 대용량 데이터 처리
    - 테이블 크기가 커질 수록 인덱스 효율 증가
- 추가 저장공간 필요
- 쓰기 작업 저하
    - INSERT, UPDATE, DELETE 작업 시 인덱스도 함께 갱신돼야함
    - 프로젝트 막바지에 인덱스 작업함
        - INSERT등이 느려서 실제 데이터 마이그레이션할 때  인덱스가 있다면 엄청 느림
- 인덱스 과다 생성 문제

### Index Scan

인덱스를 사용하면 필요한 데이터 저장 위치 빠르게 탐색 가능 

⇒ 테이블 일부만 읽으니까 성능 향상

**↔ Table Full Scan**

인덱스가 없는 경우 테이블 모든 데이터를 다 읽어서

### B-Tree Index

Balanced Tree Index

- 균형 이진트리
    - 정렬된 상태로 유지
    - 루트 → 중간 → 리프 노드 순서로 탐색
- 리프노드에 실제 데이터 위치 정보 저장
- 인덱스가 있으면 검색에는 빠르지만, 삽입 삭제 시 비효율
    - 정렬을 해야하니까

인덱스 리프 노드 탐색 - 시퀀셜

리프노드에 있는 주소로 가는 거 - 랜덤

튜닝시 블락 io 숫자 줄이는게 목표

## 인덱스 비용

### Sequential Access

- 수직적 탐색
- 수평적 탐색

### Random Access

## 유형

### 단일 컬럼 인덱스

하나의 컬럼만 기준으로 인덱스 생성

- 고객 ID, 제품 코드 등 단일 검색 기준

### 결합 인덱스

두 개 이상의 컬럼을 조합하여 생성

- 이름 + 생년월일, 제품 + 카테고리

### 유니크 인덱스

중복을 허용하지 않는 인덱스

- 휴대폰 번호, 주민등록번호

## 생성

```sql
-- SINGLE COLUMN
CREATE INDEX idx_customer_name ON customers(name);

CREATE INDEX idx_order_customer_date ON orders(customer_id, order_date);

CREATE UNIQUE INDEX idx_email ON users(email);
```

PK만들면 자동 인덱스 생성

## 확인

```sql
SELECT index_name, table_name, uniqueness
FROM user_indexes
--WHERE table_name = 'CUSTOMERS'
;
```

## 삭제

주의!!! 

```sql
DROP INDEX idx_customer_name;
```

> **인덱스가 Shared Pool과 관련되는 방식**
> 
> - SQL 문장이 Shared Pool에 저장될 때, 해당 실행 계획은 사용 가능한 인덱스를 기반으로 생성
> - 만약 이후 인덱스를 **생성**하거나 **드롭**하면, 기존의 실행 계획은 더 이상 유효하지 않을 수 있음
>     - 기존에 풀 스캔을 사용했던 실행 계획이 있었는데 새로운 인덱스가 생성되면, 옵티마이저는 더 나은 실행 계획을 위해 하드 파싱을 다시 수행할 가능성이 큼

<aside>
✨

### **SQL 파싱 (Parsing)**

사용자가 입력한 SQL 문장을 DBMS가 처리 가능한 형태로 변환하는 단계

1. **신텍스 체크 (Syntax Check)**
    - SQL 문법 오류 검사
2. **시멘틱 체크 (Semantic Check)**
    - 문법적으로는 올바르지만, 실제 데이터베이스 상태와 비교해 쿼리가 유효한지 확인
        - 테이블, 뷰, 컬럼 등이 실제로 존재하는지 확인
        - 사용자에게 필요한 권한이 있는지 확인
    - 예: 사용자가 `SELECT * FROM employees;`를 실행했는데 `employees` 테이블이 없거나, 읽기 권한이 없다면 이 단계에서 에러를 반환해.
3. **쉐어드 풀 체크 (Shared Pool Check)**
    
    이전에 실행된 SQL 문장과 실행 계획이 저장된 영역
    
    - **Shared Pool**은 SGA(System Global Area)의 일부
    - SQL 문장이 **Shared Pool**에 이미 존재 → **소프트 파싱**
    - Shared Pool에 없으면 →**하드 파싱**

---

### **소프트 파싱 (Soft Parsing)**

- 이전에 동일한 SQL 문장이 실행된 적이 있어서 **Shared Pool**에 실행 계획이 존재할 때 발생
- SQL 문장이 **완전히 동일**해야 소프트 파싱이 가능
    - 공백이나 대소문자 차이도 다른 쿼리로 간주되므로 소프트 파싱이 불가능
- 파싱보다 훨씬 빠르고 리소스 소모가 적음

---

### **하드 파싱 (Hard Parsing)**

SQL 문장이 **Shared Pool**에 없거나, 기존 계획을 재사용할 수 없는 경우 발생

- SQL 문장의 토큰화 및 분석
- **옵티마이저**가 실행 계획 생성
- 실행 계획을 Shared Pool에 저장

하드 파싱은 소프트 파싱보다 더 많은 리소스를 사용하고, 시간이 오래 걸림

### **옵티마이저 (Optimizer)**

- **Shared Pool**에 동일한 쿼리가 없을 경우, 옵티마이저가 실행 계획 생성
- 옵티마이저는 다양한 실행 방법을 비교하며 가장 비용이 적은 실행 계획을 선택

**옵티마이저의 주요 역할**:

- 테이블 조인 순서 결정
- 인덱스 사용 여부 판단
- 파티션 스캔 적용 여부 결정

---

- SQL 문장이 처음 실행되면 하드 파싱을 통해 실행 계획이 생성되고, 
이후 동일한 SQL 문장이 실행되면 소프트 파싱으로 빠르게 처리
- 하드 파싱을 최소화하려면 **SQL 문장의 재사용성** 높이는 것이 중요
    - 바인드 변수 사용
    - 표준화된 SQL 작성

</aside>

조인 → 드리븐? 드라이브?

## 인덱스 관리

### 자주 사용되는 컬럼에 생성

- WHERE, JOIN, ORDER BY, GROUP BY에 자주 등장하는 컬럼
    - 필터링, 조인, 그룹화, 정렬에 활용
- 결합 인덱스
    - `SELECT` 시 항상 같이 뽑는 컬럼이 있다면 결합인덱스로 만들어놓으면 성능 좋아질 수 잇음
        
        ⇒ random access 과정을 거치지 않을 수 있음
        
        - 결합 인덱스는 단일 인덱스 탐색으로 두 컬럼을 모두 처리

### 적절한 인덱스 개수 유지

인덱스가 많으면 DML 작업(INSERT, UPDATE, DELETE) 시 성능 저하 발생.

→ 적절한 개수를 유지하면서 불필요한 인덱스는 삭제하는 것이 중요함.

### 읽기 작업이 많은 테이블에 적합

- **중복도가 낮은 컬럼**에 인덱스를 생성해야 효율적.
    - 예: 성별(Gender)처럼 중복도가 높은 컬럼은 인덱스를 걸어도 성능 개선 효과가 미미함.
- **데이터 출력 비율에 따른 선택**:
    - 전체 데이터의 **10~15% 이하를 출력**할 때는 인덱스가 빠름.
    - 반대로 **15% 이상을 출력**하면 테이블 풀 스캔이 더 효율적일 수도 있음.

## Index Scan

### **Index Range Scan**

- 인덱스 스캔 범위를 줄이고, 테이블 액세스 빈도를 최소화하도록 설계.
- **인덱스 선행 컬럼을 조건절에 포함**해야 인덱스 스캔이 가능.
    - 예: 인덱스가 `id + name`일 때, `id`를 조건절에 포함하지 않으면 인덱스를 사용할 가능성이 낮아짐.
    

**결합 인덱스와 순서의 중요성**

- 결합 인덱스를 구성할 때는 컬럼 순서에 따라 성능 차이가 발생할 수 있음.
    - **이퀄 조건**을 포함한 컬럼을 **범위 조건**보다 앞에 배치하는 것이 유리.
    - 예:
        
        ```sql
        SELECT *
        FROM CUSTOMERS
        WHERE name = "ddd";
        ```
        
        - `id + name` 대신 `name + id` 순서로 결합 인덱스를 구성하는 것이 적합.
            - 인덱스 컬럼 순서
                
                ```sql
                SELECT *
                FROM CUSTOMERS
                WHERE name = "ddd"
                ```
                
                이런 쿼리를 많이 쓴다면
                
                index: id+name 보다는 index: name+id 가 적합
                
                전자는 인덱스를 안탈 가능성이 높음
                
- **WHERE 조건 내 컬럼 순서는 상관없음**.
    
    → 하지만 인덱스 정의 시 순서는 중요하므로, 주로 사용하는 조건에 맞게 설계해야 함.
    

쓰기 작업 최적화를 위해 변경 작업이 많은 테이블은 인덱스 테이블 최소화

카디널리티 높은 컬럼에 인덱스 생성

데이터 크기와 접근 빈도 - 대용량 데이터 테이블에서 인덱스는 필수.

## 인덱스 활용 못하는 경우

### 인덱스 컬럼에 함수 또는 연산 사용 (좌변 가공)

```sql
-- 얘는 안됨
SELECT * FROM EMPLOYEES WHERE ROUND(SALARY)=5000;
--이렇게 해야함
SELECT * FROM EMPLOYEES WHERE SALARY BETWEEN 4999.5 AND 5000.5;
```

이런 게 있긴 함

- function based index(FBI) -
    
    로그인 시 아이디를 upper 처리해야하는 경우 등
    
- Reverse Key Index
    
    인덱스에 저장되는 키 값을 반전시켜 저장
    
    - 시퀀스나 날짜 등 순차적으로 증가하는 값이 특정 인덱스 block에 과도한 경합 발생 방지
        - 특히 날짜성 데이터가 많은 곳
    - equal 검색만 가능
    - oltp환경에서 대량 삽입 작업 발생하는 경우
- Clustered Index
    
    테이블 데이터가 인덱스 순서에 따라 물리적으로 정렬되어 저장되는 인덱스
    
    인덱스와 테이블이 같은 물리적 구조를 가지므로 검색 속도가 빠름
    
    밀집도가 높아서? 보통의 인덱스보다빠름?
    
- IOT (Index Organized Table)
    - leaf block == 테이블
        - 테이블 자체가 트리구조로
    - 테이블 데이터를 B-Tree 인덱스에 저장
    - PK 검색만 빠름

### 데이터 타입 불일치

```sql
-- 인덱스 사용 불가
SELECT * FROM EMPLOYEES WHERE EMPLOYEE_ID = '101';

-- 인덱스 사용 가능
SELECT * FROM EMPLOYEES WHERE EMPLOYEE_ID = 101;
```

### 와일드 카드 (%) 사용 위치

- 앞에 있다면 안됨
    - 인덱스는 앞글자 기준으로 정렬이 돼있으니까
    - 그래서 앞에 꼭 붙여야하는가 생각해봐야함

```sql
-- 인덱스 사용 불가
SELECT * FROM EMPLOYEES WHERE NAME LIKE '%JHON%';

-- 인덱스 사용 가능
SELECT * FROM EMPLOYEES WHERE NAME LIKE 'JHON%';
```

### NULL 값 처리

- 저장이 안됨

```sql
--
SELECT FROM EMPLOYEES WHERE NAME LIKE IS NULL;

ALTER FROM EMPLOYEES MODIFY NAME DEFAULT '000';
-- 이경우 이전 데이터는 NULL로 남아있고 앞으로 데이터만 이렇게
```

### OR 조건 포함된 경우

- 요즘엔 옵티마이저가 union all로 쿼리 변환 해줘서 될 수도

```sql
SELECT FROM EMPLOYEES WHERE EMPLOYEE_ID = 101 OR NAME = '000'

SELECT FROM EMPLOYEES WHERE EMPLOYEE_ID = 101 
UNION ALL
SELECT FROM EMPLOYEES WHERE NAME = '000'

```
