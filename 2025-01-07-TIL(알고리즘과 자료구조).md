# **시간 복잡도**

> 알고리즘이 실행되는 데 걸리는 시간을 입력 크기와의 관계로 표현한 것.
> 

## **점근적 표기법**

시간 복잡도를 근사치로 표현

### **Ω(오메가)**

최선의 경우를 나타냄.

### **Θ(세타) 표기법**

평균적인 경우를 나타냄.

### **Big-O**

최악의 경우를 나타냄.

## **문제 해결 단계에 따른 시간 복잡도**

| **시간 복잡도 유형** | **예시 작업** | **설명** |
| --- | --- | --- |
| **상수 시간 (**$O(1)$**)** | 배열의 특정 인덱스 접근 | 입력 크기와 상관없이 항상 일정한 시간이 걸림. |
| **로그 시간 (**$O(\log n)$**)** | 이진 탐색 | 입력 크기가 증가할수록 처리 시간이 느리게 증가하며, 효율적인 탐색 알고리즘에서 자주 등장. |
| **선형 시간 (**$O(n)$**)** | 배열 순회, 리스트 탐색 | 입력 크기에 비례하여 작업 시간이 증가. |
| **선형 로그 시간 (**$O(n \log n)$**)** | 병합 정렬, 퀵 정렬 | 입력 크기가 커질수록 시간 복잡도가 로그 성분만큼 추가로 증가. |
| **이차 시간 (**$O(n^2)$**)** | 이중 반복문, 버블 정렬 | 반복문이 중첩된 경우 발생하며, 입력 크기가 증가할수록 처리 시간이 급격히 증가. |
| **지수 시간 (**$O(2^n)$**)** | 재귀 호출 기반 문제 해결 (피보나치 수열) | 입력 크기가 작을 때는 해결 가능하지만, 입력 크기가 커지면 처리 시간이 매우 급격히 증가. |
| **팩토리얼 시간 (**$O(n!)$**)** | 순열 생성, 조합 문제 해결 | 입력 크기에 따라 모든 경우를 탐색해야 하므로 가장 비효율적인 시간 복잡도를 가짐. |

## **Big-O Complexity Chart**

- 알고리즘의 시간 복잡도를 그래프로 표현.

## **시간 복잡도 예시**

- 선형 탐색: O(n)
- 이진 탐색: O(log n)

### 정렬 알고리즘 비교

| **정렬 알고리즘** | **최선 (Ω)** | **평균 (Θ)** | **최악 (O)** | **공간 복잡도** | **비고** |
| --- | --- | --- | --- | --- | --- |
| **버블 정렬** | O(n) | O(n²) | O(n²) | O(1) | 단순 구현, 비효율적. |
| **선택 정렬** | O(n²) | O(n²) | O(n²) | O(1) | 항상 O(n²), 안정적이지 않음. |
| **삽입 정렬** | O(n) | O(n²) | O(n²) | O(1) | 거의 정렬된 경우 효율적. |
| **힙 정렬** | O(n log n) | O(n log n) | O(n log n) | O(1) | 불안정 정렬, 힙 사용. |
| **퀵 정렬** | O(n log n) | O(n log n) | O(n²) | O(log n) | 불안정 정렬, 피벗 선택 중요. |
| **병합 정렬** | O(n log n) | O(n log n) | O(n log n) | O(n) | 안정적 정렬, 추가 메모리 필요. |
| **계수 정렬** | O(n+k) | O(n+k) | O(n+k) | O(k) | 숫자 범위 제한 시 매우 빠름. |
| **기수 정렬** | O(nk) | O(nk) | O(nk) | O(n+k) | 안정적 정렬, 숫자 또는 문자열에 적합. |
| **쉘 정렬** | O(n log n) | O((n log n)²) | O(n²) | O(1) | 간격 최적화 시 성능 향상 가능. |

### 자료구조 비교

| **자료구조** | **검색 (O)** | **삽입 (O)** | **삭제 (O)** | **비고** |
| --- | --- | --- | --- | --- |
| **배열 (Array)** | O(n) | O(n) | O(n) | 고정 크기, 특정 위치 접근은 O(1). |
| **동적 배열 (Vector/List)** | O(n) | O(1) (평균) | O(n) | 크기 자동 조정, 끝에 삽입은 O(1) (평균). |
| **단일 연결 리스트** | O(n) | O(1) | O(1) | 노드 접근은 순차적. |
| **이중 연결 리스트** | O(n) | O(1) | O(1) | 양방향 링크로 노드 탐색 용이. |
| **스택 (Stack)** | O(n) | O(1) | O(1) | LIFO 구조, 끝에서만 삽입/삭제 가능. |
| **큐 (Queue)** | O(n) | O(1) | O(1) | FIFO 구조, 앞에서 삭제, 뒤에서 삽입. |
| **우선순위 큐** | O(log n) | O(log n) | O(log n) | 힙으로 구현 시 효율적. |
| **해시 테이블** | O(1) (평균) | O(1) (평균) | O(1) (평균) | 충돌 시 O(n), 체이닝 또는 개방 주소법 필요. |
| **이진 탐색 트리 (BST)** | O(log n) | O(log n) | O(log n) | 불균형 시 O(n), 균형 트리 사용 권장. |
| **AVL 트리** | O(log n) | O(log n) | O(log n) | 균형 유지, 삽입/삭제 시 추가 연산 필요. |
| **레드블랙 트리** | O(log n) | O(log n) | O(log n) | 균형 유지, 삽입/삭제 시 색상 변경 연산 포함. |
| **B-트리** | O(log n) | O(log n) | O(log n) | 대량 데이터 처리에 적합. |
| **그래프 (인접 리스트)** | O(V+E) | O(1) | O(E) | 정점 검색은 느림, 간선 삭제 시 E 탐색 필요. |
| **그래프 (인접 행렬)** | O(1) | O(1) | O(1) | 정점 추가/삭제는 O(V²). |

---

# **자료구조**

## **배열**

> **같은 자료형**의 데이터를 순서대로 나열한 구조
> 

고정된 크기의 **연속적**인 메모리 공간

각 요소는 인덱스로 접근

### **1차원 배열**

인덱스를 하나만 사용하는 배열

### **2차원 배열**

인덱스를 두 개 사용하는 배열

- 행과 열로 구성된 배열

### **배열에서 데이터 삽입/삭제**

- 삽입: 특정 위치에 데이터를 추가.
- 삭제: 특정 위치의 데이터를 제거.

## **연결 리스트**

- 각 데이터를 포인터로 연결하여 관리
    - 각 노드의 메모리 위치는 상관 없음
    - 요소들이 메모리상에서 연속적이지 않고 각 노드는 동적 할당
- 데이터 영역에 여러 개 데이터가 저장될 수 있음
- 데이터 삽입 삭제가 용이

### **단순 연결 리스트**

노드에 포인터 영역이 하나

- 각 노드가 다음 노드에 대한 참조를 가짐

```python
class Node:
  def __init__(self, data):
    self.data = data
    self.next = None

class SinglyLinkedList:
  def __init__(self):
    self.head = None

  def append(self, data):
    new_node = Node(data)
    if not self.head:
      self.head = new_node
      return
    last = self.head
    while last.next:
      last = last.next
    last.next = new_node

  def prepend(self, data):
    new_node = Node(data)
    new_node.next = self.head
    self.head = new_node

  def delete(self, data):
    temp = self.head
    if temp and temp.data == data:
      self.head = temp.next
      temp = None
      return

    prev = None
    while temp and temp.data != data:
      prev = temp
      temp = temp.next

    if temp is None:
      return

    prev.next = temp.next
    temp = None

  def display(self):
      temp = self.head
      while temp:
          print(temp.data, end=" -> ")
          temp = temp.next
      print("None")
```

### **이중 연결 리스트**

각 노드가 이전 노드와 다음 노드에 대한 참조를 가짐

## **스택**

> LIFO(Last In, First Out) 구조
> 
- 데이터를 스택의 최상단에 추가.
- 최상단 데이터를 제거.

```python
stack=[]
while True:
    select=int(input('1:삽입, 2:삭제, 3:종료 '))
    if select==1:
        data=int(input('삽입할 데이터: '))
        stack.append(data)
        print(stack)
    elif select==2:
        if len(stack)==0:
            print('스택이 비었습니다.')
        else:
            data=stack.pop()
            print('삭제된 데이터:', data)
            print(stack)
    else:
        break
```

## **큐**

> FIFO(First In, First Out) 구조
> 
- 데이터를 큐의 끝에 추가
- 데이터를 큐의 앞에서 제거

```python
queue=[]
while True:
    select=int(input('1:삽입, 2:삭제, 3:종료 '))
    if select==1:
        data=int(input('삽입할 데이터: '))
        queue.append(data)
        print(queue)
    elif select==2:
        if len(queue)==0:
            print('큐가 비었습니다.')
        else:
            data=queue.pop(0)
            print('삭제된 데이터:', data)
            print(queue)
    else:
        break
```

### **우선순위 큐**

우선순위에 따라 데이터를 삽입/삭제

- 배열, 리스트
- 힙

```python
# 최소힙
import heapq

# 빈 우선순위 큐 생성
pq = []

# 요소 삽입 (우선순위, 데이터 형식으로 삽입)
heapq.heappush(pq, (2, "task 2"))
heapq.heappush(pq, (1, "task 1")) #우선순위가 가장 작음
heapq.heappush(pq, (3, "task 3"))

# 우선순위가 가장 작은 요소 꺼내기 (최소 힙이므로 가장 작은 우선순위가 먼저 나옵니다)
priority, task = heapq.heappop(pq)
print(f"Task with priority {priority}: {task}")

# 최대힙
import heapq

# 빈 우선순위 큐 생성
pq = []

# 최대 힙처럼 사용하기 위해 우선순위에 -1을 곱해 삽입
heapq.heappush(pq, (-2, "task 2"))
heapq.heappush(pq, (-1, "task 1"))
heapq.heappush(pq, (-3, "task 3")) #우선순위가 가장 큼

# 우선순위가 가장 큰 요소 꺼내기 (최대 힙처럼 작동)
priority, task = heapq.heappop(pq)
print(f"Task with priority {-priority}: {task}")
```

## **그래프**

> 정점과 간선으로 이루어진 구조
> 
> - 정점(node, vertex)
> - 간선(edge)
> - 차수(degree)
> 정점에 연결된 간선의 개수
- 무방향 그래프
- 방향 그래프
- 완전 그래프
- 가중 그래프
- 다중 그래프
- 유사 그래프
- 루프

### **그래프 표현**

- **인접 리스트**
    
    각 정점의 이웃을 리스트로 표현
    
- **인접 행렬**
    
    정점 간의 연결을 행렬로 표현
    
- **근접 행렬**
    
    정점과 간선의 관계를 나타내는 행렬 - 거리 정보를 포함한 행렬
    

### **경로**

한 정점에서 다른 정점으로 가는 길

### **탐색 알고리즘**

### **깊이 우선 탐색 (DFS)**

한 경로를 끝까지 탐색 후 다른 경로 탐색

```python
# 재귀 방식
def dfs(graph, v, visited):
    # 현재 정점을 방문
    visited[v] = True
    print(v, end=" ")

    # 현재 정점과 인접한 정점들 중 방문하지 않은 정점 방문
    for neighbor in graph[v]:
        if not visited[neighbor]:
            dfs(graph, neighbor, visited)

# 그래프와 호출 예시
graph = {
    0: [1, 2],
    1: [0, 3, 4],
    2: [0],
    3: [1],
    4: [1]
}
visited = [False] * 5  # 5개의 정점에 대해 방문 여부 기록
dfs(graph, 0, visited)

```

```python
# 스택을 이용한 반복 방식

def dfs(graph, start):
    visited = [False] * len(graph)  # 방문 여부 기록
    stack = [start]  # 시작 정점은 스택에 넣고 시작

    while stack:
        v = stack.pop()  # 스택에서 정점을 꺼냄
        if not visited[v]:  # 방문하지 않은 정점만 방문
            visited[v] = True
            print(v, end=" ")

        # 인접한 정점 중에서 방문하지 않은 정점만 스택에 넣음
        for neighbor in reversed(graph[v]):  # LIFO 순서로 탐색
            if not visited[neighbor]:
                stack.append(neighbor)

# 그래프와 호출 예시
graph = {
    0: [1, 2],
    1: [0, 3, 4],
    2: [0],
    3: [1],
    4: [1]
}

dfs(graph, 0)

```

### **너비 우선 탐색 (BFS)**

정점과 동일 레벨의 모든 정점을 탐색

```python
from collections import deque

def bfs(graph, start):
    visited = [False] * len(graph)  # 방문 여부 기록
    queue = deque([start])  # 시작 정점을 큐에 넣고 시작
    visited[start] = True  # 시작 정점 방문 처리

    while queue:
        v = queue.popleft()  # 큐에서 정점 하나를 꺼냄
        print(v, end=" ")

        # 인접한 정점 중 방문하지 않은 정점 큐에 넣음
        for neighbor in graph[v]:
            if not visited[neighbor]:
                visited[neighbor] = True
                queue.append(neighbor)
# 그래프와 호출 예시
graph = {
    0: [1, 2],
    1: [0, 3, 4],
    2: [0],
    3: [1],
    4: [1]
}

bfs(graph, 0)

```

## **트리**

> 계층적 데이터 구조로, 루트 노드와 자식 노드로 구성
> 
> - 왼쪽/오른쪽 서브 트리로 구분
> - 연결리스트, 배열

### **이진 트리**

모든 노드의 자식 노드가 두 개 이하인 트리

- **완전 이진 트리**
모든 노드가 자식 노드를 두 개 가짐
- **포화 이진 트리**
완전이진트리 + 깊이가 같음
- **이진 탐색 트리 (BST)**
중복 값이 없고 왼쪽 자식 노드는 루트보다 작고 오른쪽 자식은 루트보다 크다

### **이진 트리 순회**

| **순회 방식** | **방문 순서** | **결과 예시** |  |
| --- | --- | --- | --- |
| 전위 순회 | 루트 → 왼쪽 → 오른쪽 | 4 → 2 → 1 → 3 → 5 | 트리 구조를 복제하거나 저장할 때 유용 |
| 중위 순회 | 왼쪽 → 루트 → 오른쪽 | 1 → 2 → 3 → 4 → 5 | 오름차순 정렬된 값 |
| 후위 순회 | 왼쪽 → 오른쪽 → 루트 | 1 → 3 → 2 → 5 → 4 | 하위 작업(예: 삭제)을 먼저 수행하고, 상위 작업(루트 노드)을 나중에 처리할 때 유용 |

---

### **균형 문제**

- 트리의 균형 상태를 유지하는 방법

### **균형 이진 탐색 트리**

트리가 균형을 이루지 못하면 특정 연산(삽입, 삭제, 탐색 등)의 시간 복잡도가 비효율적으로 증가

- **AVL 트리**
    
    높이 균형 조건을 유지하는 이진 탐색 트리
    
    - 각 노드의 왼쪽 서브트리와 오른쪽 서브트리의 높이 차이가 1 이하
    - 삽입 및 삭제 시 **회전 연산**을 사용하여 균형을 유지
- **레드블랙 트리**
    
    노드에 색깔(빨간색 또는 검은색)을 추가하여 균형을 유지하는 이진 탐색 트리
    
    - 루트에서 리프까지의 경로 중 검은색 노드의 개수가 동일함
    - 삽입 및 삭제 시 색상 변경과 회전을 통해 균형 유지

## **힙**

> 최대값 또는 최소값을 빠르게 찾을 수 있는 자료구조
> 

![위 그림은 모두 이진트리인데, (a)는 힙이지만 (b)는 힙이 아니다.
(b)는 왼쪽부터 채워야 한다는 규칙을 벗어났다.](https://wikidocs.net/images/page/194445/ds-059.png)

위 그림은 모두 이진트리인데, (a)는 힙이지만 (b)는 힙이 아니다.
(b)는 왼쪽부터 채워야 한다는 규칙을 벗어났다.

- Heapify 과정으로 생성

### **힙의 활용**

- 우선순위 큐, 정렬 등에 사용

## **몬테카를로 탐색**

> 반복적으로 트리를 확장하며 각 노드에서 가능한 시나리오를 시뮬레이션하여 가장 유망한 경로 선택
> 
- 선택
    
    루트 노드에서 시작하여 UCT 기준에 따라 가장 유망한 자식 노드 선택
    
- 확장
    
    선택한 노드가 리프 노드라면 가능한 자식 노드 추가
    
- 시뮬레이션
    
    무작위로 게임 진행하고 종료 상태 시뮬레이션
    
- 역전파
    
    시뮬레이션 결과를 바탕으로 각 노드의 wins/visits 업데이트하여 더 나은 결정 내리도록 함
    

---

# **정렬 알고리즘**

### **선택 정렬**

정렬되지 않은 데이터 중 가장 작은 데이터를 맨 앞 데이터와 교환

- 제일 작은 게 맨 앞으로 가게 됨

```python
def selection(ds):
    for a in range(0, len(ds)-1):
        min_ind = a # 일단 첫번째 인덱스가 최솟값 인덱스라고 생각
        for b in range(a+1, len(ds)):
            if ds[b] < ds[min_ind]:
                min_ind = b
        ds[a], ds[min_ind] = ds[min_ind], ds[a]

dataset = [20, 50, 30, 10, 60, 40]
selection(dataset)
print(dataset)

```

### **삽입 정렬**

정렬되지 않은 데이터를 이미 정렬된 부분의 적절한 위치에 삽입해가며 정렬

```python
def insertion(ds):
    for a in range(1, len(ds)):
        key = ds[a]
        b = a-1
        while b>=0 and ds[b]>key:
            ds[b+1] = ds[b] # key 넣을 자리 만들려고 뒤로 빼는 거인듯
            b = b-1
        ds[b+1] = key

dataset = [20, 50, 30, 10, 60, 40]
insertion(dataset)
print(dataset)
```

### **버블 정렬**

인접 데이터를 교환하며 정렬

- 제일 큰 게 맨 뒤로 가게 됨

```python
def bubble(ds):
    for a in range(0, len(ds)-1):
        for b in range(0, len(ds)-1-a):
            if ds[b] > ds[b+1]:
                ds[b], ds[b+1] = ds[b+1], ds[b]

dataset = [20, 50, 30, 10, 60, 40]
bubble(dataset)
print(dataset)
```

### **퀵 정렬**

피벗을 기준으로 분할 정렬

```python
def quick(ds):
    if len(ds) < 2:
        return ds
    else:
        key = ds[0]
        left = [data for data in ds[1:] if data <= key]
        right = [data for data in ds[1:] if data > key]
        return quick(left) + [key] + quick(right)

dataset = [20, 50, 30, 10, 60, 40]
print(quick(dataset))
```

### **병합 정렬**

분할 후 정렬하여 병합

- 분할 정복

### **힙 정렬**

힙을 이용한 정렬

---

# **해시 테이블**

> 키와 값을 저장하는 데이터 구조
> 
- 검색, 삽입: $O(1)$ (평균)

## **충돌 해결 방법**

- 체이닝
    
    같은 인덱스에 여러 값을 저장할 수 있도록 연결 리스트를 사용하여 충돌 해결
    
- 개방 주소법.
    
    충돌이 발생하면 다른 빈 슬롯을 찾아 데이터 삽입
    
    - 선형탐사, 이차탐사, 이중 해싱

---

# **알고리즘 기법**

## **탐색 알고리즘**

### **선형 탐색**

순차적으로 데이터를 탐색 

- $O(n)$

```python
def linear(ds, key):
    for a in range(0, len(ds)):
        if key == ds[a]:
            return a
    return

dataset = [20, 50, 30, 10, 60, 40]
print(linear(dataset, 10))

```

### **이진 탐색**

**정렬된 데이터**에서 절반씩 나누며 탐색 

- $O(\log n)$

```python
def binary(ds, key):
    low = 0
    high = len(ds)-1
    while low <= high:
        mid = (low+high)//2
        if key == ds[mid]:
            return mid
        elif key < ds[mid]:
            high = mid-1
        else:
            low = mid+1
    return

dataset = [10, 20, 30, 40, 50]
print(binary(dataset, 20))
```

## **재귀 알고리즘**

> 자기 자신을 호출하는 알고리즘
> 

### **팩토리얼**

$n! = n * (n-1)!$

```python
def factorial(n):
	if n==0:
		return 1
	else:
		return n*factorial(n-1)
```

### **피보나치 수열**

$F(n) = F(n-1) + F(n-2)$

```python
def fibo(n):
	if n<=2:
		return 1
	return fibo(n-1) + fibo(n-2)
```

## **그리디 알고리즘**

> 매 단계에서 최적의 선택을 하는 알고리즘.
> 

### **최소 신장 트리(Minimum Spanning Tree, MST)**

주어진 그래프에서 모든 노드를 연결할 수 있는 트리 구조를 찾고 그 트리 간선의 가중치 합이 최소가 되도록 만드는 문제

### **Kruskal 알고리즘**

- 간선 중심

### **Prim 알고리즘**

- 정점 중심

## **다익스트라 알고리즘**

> 가중 그래프에서 최단 경로 탐색.
> 
- $O(V^2)$ 또는 $O(E log V)$ (힙 사용)

## **동적 프로그래밍**

> 작은 문제를 해결한 결과를 저장하여 재활용
> 

### **메모이제이션 (Memoization)**

재귀적 저장

- 한 번 계산된 값은 저장 - 중복 계산 방지
- Top-Down

### **타뷸레이션 (Tabulation)**

반복적 저장

- DP 테이블을 채워가며 해결 - 작은 문제부터 차례대로
- Bottom-Up

### **피보나치 수열**

- Memoization
    
    ```python
    def fibonacci_memo(n, memo={}):
    	if n<=1:
    		return n
    	if n not in memo:
    		memo[n] = fibonacci_memo(n-1, memo) + fibonacci_memo(n-2, memo)
    
    return memo[n]
    ```
    
- Tabulation
    
    ```python
    def fibonacci_tab(n):
    	dp = [0]*(n+1)
    	dp[1] = 1
    	for i in range(2, n+1):
    		dp[i] = dp[i-1] + dp[i-2]
    return dp[n]
    ```
    

### **배낭 문제**

주어진 물건들의 무게와 가치를 고려하여 배낭의 용량을 넘지 않도록 선택할 수 있는 최대 가치를 구하시오

- 점화식
    
    `dp[i][w] = max(dp[i-1][w], dp[i-1][w-weight[i]]+value[i])`
    
- Tabulation
