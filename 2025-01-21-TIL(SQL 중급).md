# 윈도우 함수

SQL에서 행을 기준으로 특정 범위(Window)를 정의하여 작업하는 함수

- 집계 함수와 함께 데이터를 그룹핑 하지 않고도 계산 가능

### 순위 함수

<aside>
✨

### DENSE_RANK와 RANK, ROW_NUMBER의 차이

| 윈도우 함수 | 설명 | 예시 순위 (5000, 5000, 4500, 4000) |
| --- | --- | --- |
| `RANK` | 동일 값에 동일 순위를 부여하고, 다음 순위를 건너뜀 | 1, 1, 3, 4 |
| `DENSE_RANK` | 동일 값에 동일 순위를 부여하지만, 다음 순위를 건너뛰지 않음 | 1, 1, 2, 3 |
| `ROW_NUMBER` | 고유한 순위를 부여 (동일 값도 고유 순위) | 1, 2, 3, 4 |

---

### 선택 기준

- **`DENSE_RANK`**: 동일한 최대값이 여러 행에 있을 때, **모두 반환**해야 하는 경우 적합.
- **`RANK`**: 동일한 최대값이 여러 행에 있어도, 이후 순위의 **간격을 유지**해야 하는 경우 적합.
- **`ROW_NUMBER`**: 동일한 값 중 하나의 행만 반환하거나 고유 순위가 필요할 때 적합.

`DENSE_RANK`는 동일한 값을 다룰 때 가장 자연스럽게 순위를 표현할 수 있는 방법입니다!

</aside>

`PARTITION BY`

`ORDER BY`

### `RANK`

순위를 계산하며 동일한 값은 같은 순위 부여

- 순위 건너뜀
    - 1, 2, 2, 4, 5 …

```sql
SELECT EMPLOYEE_ID, NAME, SALARY,
        RANK() OVER (ORDER BY SALARY DESC) AS rank
FROM EMPLOYEES
WHERE SALARY IS NOT NULL;

SELECT DEPARTMENT_ID, EMPLOYEE_ID, NAME, SALARY,
        RANK() OVER (PARTITION BY DEPARTMENT_ID
                        ORDER BY SALARY DESC) AS rank
FROM EMPLOYEES
WHERE SALARY IS NOT NULL;
```

- RANK =1 을 뽑아내는 법!
    
    ```sql
    SELECT * FROM (
                    SELECT DEPARTMENT_ID, EMPLOYEE_ID, NAME, SALARY,
            RANK() OVER (PARTITION BY DEPARTMENT_ID
                            ORDER BY SALARY DESC NULLS LAST) AS rank
            FROM EMPLOYEES
    )
    WHERE rank = 1;
    ```
    

### `DENSE_RANK`

밀집 순위 계산

- 1, 2, 2, 3, 4, …
동일한 최대값이 여러 행에 있을 때, **모두 반환**해야 하는 경우 적합
- 동적 쿼리 —> 순위 조건 입력 받을 때, 1위가 여러명일 수 있을때
    - 1등 여러 명, 2등 여러 명
- ORDER BY → 누적치를 구하겠다

```sql
SELECT EMPLOYEE_ID, NAME, SALARY,
        DENSE_RANK() OVER (ORDER BY SALARY DESC) AS dense_rank
FROM EMPLOYEES
WHERE SALARY IS NOT NULL;
```

### `ROW_NUMBER`

동일한 값이 있을 때도 고유한 순위가 나옴.

- 동일한 값 안에서 순위는 랜덤. DB 마음임.

```sql

```

## 집계함수

### SUM 함수

```sql
-- 부서별 급여 합계
SELECT EMPLOYEE_ID, DEPARTMENT_ID, SALARY,
        SUM(SALARY) OVER (PARTITION BY DEPARTMENT_ID) AS DEPT_TOTAL -- 그냥 부서 전체 합계
FROM EMPLOYEES; 

SELECT EMPLOYEE_ID, DEPARTMENT_ID, SALARY,
        SUM(SALARY) OVER (PARTITION BY DEPARTMENT_ID
                            ORDER BY SALARY) AS DEPT_TOTAL -- 누적합으로 나옴
FROM EMPLOYEES;
```

### AVG 함수

```sql
-- 부서별 평균 급여
SELECT EMPLOYEE_ID, DEPARTMENT_ID, SALARY,
        AVG(SALARY) OVER (PARTITION BY DEPARTMENT_ID) AS DEPT_AVG -- 그냥 부서 전체 합계
FROM EMPLOYEES; 

SELECT EMPLOYEE_ID, DEPARTMENT_ID, SALARY,
        AVG(SALARY) OVER (PARTITION BY DEPARTMENT_ID
                            ORDER BY SALARY) AS DEPT_AVG -- 누적합으로 나옴
FROM EMPLOYEES;
```

### MAX

```sql
-- 부서별 최고 급여
SELECT EMPLOYEE_ID, DEPARTMENT_ID, SALARY,
        MAX(SALARY) OVER (PARTITION BY DEPARTMENT_ID) AS DEPT_MAX -- 그냥 부서 전체 합계
FROM EMPLOYEES; 

SELECT EMPLOYEE_ID, DEPARTMENT_ID, SALARY,
        MAX(SALARY) OVER (PARTITION BY DEPARTMENT_ID
                            ORDER BY SALARY) AS DEPT_MAX -- 누적합으로 나옴
FROM EMPLOYEES;

-- 최고 급여 받는 사람들
SELECT * FROM (SELECT EMPLOYEE_ID, DEPARTMENT_ID, SALARY,
                MAX(SALARY) OVER (PARTITION BY DEPARTMENT_ID) AS DEPT_MAX 
                FROM EMPLOYEES
) WHERE DEPT_MAX = SALARY;

```

### MIN

```sql
-- 부서별 최저 급여
SELECT EMPLOYEE_ID, DEPARTMENT_ID, SALARY,
        MIN(SALARY) OVER (PARTITION BY DEPARTMENT_ID) AS DEPT_MIN -- 그냥 부서 전체 합계
FROM EMPLOYEES; 

SELECT EMPLOYEE_ID, DEPARTMENT_ID, SALARY,
        MIN(SALARY) OVER (PARTITION BY DEPARTMENT_ID
                            ORDER BY SALARY) AS DEPT_MIN -- 누적합으로 나옴
FROM EMPLOYEES;

SELECT * FROM (SELECT EMPLOYEE_ID, DEPARTMENT_ID, SALARY,
                MIN(SALARY) OVER (PARTITION BY DEPARTMENT_ID) AS DEPT_MIN 
                FROM EMPLOYEES
) WHERE DEPT_MIN = SALARY;
```

### COUNT

```sql
-- 부서별 직원 수
SELECT EMPLOYEE_ID, DEPARTMENT_ID, 
        COUNT(EMPLOYEE_ID) OVER (PARTITION BY DEPARTMENT_ID) AS DEPT_COUNT 
FROM EMPLOYEES; 

SELECT EMPLOYEE_ID, DEPARTMENT_ID, SALARY,
        COUNT(EMPLOYEE_ID) OVER (PARTITION BY DEPARTMENT_ID
                            ORDER BY SALARY) AS DEPT_COUNT 
FROM EMPLOYEES;
```

### `PARTITION BY`

데이터를 특정 그룹으로 나눔

그룹별로 윈도우 함수 작동

### `ORDER BY`

데이터를 정렬하여 윈도우 함수 동작 순서 지정

누적 계산에 주로 사용

### () 아무 조건도 없을 때

랜덤 순서로 정렬되고 값은 전체 데이터 기준

```sql
SELECT EMPLOYEE_ID, SALARY,
        SUM(SALARY) OVER () AS FUTURE_SUM
FROM EMPLOYEES;
```

- FUTURE_SUM
    - 전체 급여 합계로 통일
- 정렬
    - EMPLOYEE_ID로 정렬 됨

### 이동평균

### 누적 합계

### 그룹별 최대/최소값

## 옵션

윈도우 함수에서 특정 행이나 범위를 지정하는 추가 설정

옵션을 활용해 데이터 처리 범위를 유연하게 조정 가능

### ROWS

물리적 행(Row)을 기준으로 범위 지정

- 행 순서

```sql
-- 현재 행을 기준으로 이전 2행과 값을 합산

SELECT EMPLOYEE_ID, SALARY, 
				SUM(SALARY) OVER (ORDER BY SALARY ROWS 2 PRECEDING) AS SALARY_SUM
FROM EMPLOYEES;
```

### RANGE

논리적 값(Value)을 기준으로 범위 지정

- 값 범위
    - 숫자형에만 사용할 수 있음
        - 내 점수보다 +-10점인 사람 몇명이야?

```sql
SELECT EMPLOYEE_ID, SALARY,
			SUM(SALARY) OVER (ORDER BY SALARY 
												RANGE UNBOUNDED PRECEDING) AS SALARY_SUM
FROM EMPLOYEES;
```

### [UNBOUNDED | $N$] PRECEDING

(맨) 앞

### CURRENT ROW

현재 행을 기준으로 윈도우 설정

```sql
-- 현재 행부터 이후 값 합계
SELECT EMPLOYEE_ID, SALARY,
        SUM(SALARY) OVER (ORDER BY SALARY 
                            ROWS BETWEEN CURRENT ROW 
                            AND UNBOUNDED FOLLOWING) AS FUTURE_SUM
FROM EMPLOYEES;
```

### [UNBOUNDED | $N$] FOLLOWING

(맨) 뒤

```sql
-- 현재 행부터 이후 두 개 행 값 합계
SELECT EMPLOYEE_ID, SALARY,
        SUM(SALARY) OVER (ORDER BY SALARY 
                            ROWS BETWEEN CURRENT ROW 
                            AND 2 FOLLOWING) AS FUTURE_SUM
FROM EMPLOYEES;
```

### 복합 옵션

복합 옵션으로 윈도우 설정 가능

- 예시) 연도별 매출 증가율 - 연도별로 끊음, 월 누적

```sql
-- 부서별 급여 누적 합계
SELECT EMPLOYEE_ID, DEPARTMENT_ID, SALARY, 
        SUM(SALARY) OVER (PARTITION BY DEPARTMENT_ID 
                            ORDER BY SALARY 
                            ROWS UNBOUNDED PRECEDING) AS CUM_SALARY
FROM EMPLOYEES;
```

### EX)

- 1 ~ 현재
    
    ROWS BETWEEN
    UNBOUNDED PRECEDING
    AND CURRENT ROW
    
- 현재 ~ N
    
    ROWS BETWEEN
    CURRENT ROW AND
    UNBOUNDED FOLLOWING
    
- k-1 ~ k+1
    
    ROWS BETWEEN
    1 PRECEDING AND
    1 FOLLOWING
    
- 1 ~ K - CURRENT ROW 생략
    
    ROWS UNBOUNDED PRECEDING
    
- 
    
    RANGE BETWEEN UNBOUNDED
    PRECEDING AND CURRENT ROW
    
- 
    
    RANGE BETWEEN CURRENT ROW
    AND UNBOUNDED FOLLOWING
    

- 
- ACCOUNTS 테이블에서 고객별 누적 잔액 조회

```sql
SELECT CUSTOMER_ID, ACCOUNT_ID, BALANCE,
			SUM(BALANCE) OVER (PARTITION BY CUSTOMER_ID ORDER BY ACCOUNT_ID) AS CUM_BALANCE
FROM ACCOUNTS;
```

- LOANS 테이블에서 지점 별 최고 대출 금액 계산
    
    대출 테이블 내 모든 데이터가 나오고 그 옆에 최대 금액이 붙어서 나옴
    
    - 근데 정렬이 SELECT 컬럼 순서대로 정렬되는듯?

```sql
SELECT BRANCH_ID, CUSTOMER_ID, MAX(AMOUNT) OVER(PARTITION BY BRANCH_ID) AS MAX_AMOUNT
FROM LOANS;

```

# 계층 쿼리

데이터가 부모-자식 관계로 구성된 계층적 구조를 조회하기 위한 쿼리

- 트리 구조 데이터를 표현하고 탐색하는 데 사용

```sql
SELECT col_name, LEVEL
FROM talbe_name
START WITH 
CONNECT BY PRIOR
```

```sql
SELECT EMPLOYEE_ID, NAME, LEVEL
FROM EMPLOYEES
START WITH MANAGER_ID IS NULL
CONNECT BY PRIOR EMPLOYEE_ID = MANAGER_ID;
```

- 순방향이냐 역방향이냐?? → PRIOR

### START WITH

계층 구조의 시작점

### CONNECT BY

부모-자식 관계 정의

### PRIOR

계층 방향성

PRIOR가 어디 붙어있냐에 따라 부모 → 자식, 자식 → 부모 방향 결정 / 순방향, 역방향

CONNECT BY PRIOR EMPLOYEE_ID = MANAGER_ID : 부모 → 자식 == 순방향

부모 옆에 붙으면 (PRIOR MANAGER_ID =EMPLOYEE_ID) 자식 → 부모

```sql
-- 21의 상사 계층만
SELECT EMPLOYEE_ID, NAME, DEPARTMENT_ID, LEVEL
FROM EMPLOYEES
START WITH EMPLOYEE_ID = 22
CONNECT BY EMPLOYEE_ID = PRIOR MANAGER_ID;

-- 21의 부하 계층만
SELECT EMPLOYEE_ID, NAME, DEPARTMENT_ID, LEVEL
FROM EMPLOYEES
START WITH EMPLOYEE_ID = 22
CONNECT BY PRIOR EMPLOYEE_ID =  MANAGER_ID
--ORDER SIBLINGS BY NAME
;
```

### ORDER SIBLINGS BY

계층 구조에서 동일한 부모를 가지는 행(동일 레벨) 데이터 정렬

- 원래 계층별로 나옴

그냥 ORDER BY 사용하면 계층구조 무너짐

### LEVEL

계층 깊이를 나타내는 가상 컬럼

ROOT = 1

```sql
-- SHOPPING_CATEGORIES 테이블에서 전체 계층 구조 조회
SELECT CATEGORY_ID,
				PARENT_CATEGORY_ID,
				CATEGORY_NAME,
				LEVEL
FROM SHOPPING_CATEGORIES
START WITH PARENT_CATEGORY_ID IS NULL
CONNECT BY PRIOR CATEGORY_ID = PARENT_CATEGORY_ID;				
```

### SYS_CONNECT_BY_PATH

계층 구조 경로 조회

```sql
SELECT EMPLOYEE_ID, NAME, LTRIM(SYS_CONNECT_BY_PATH(NAME, '->'), '->') AS PATH
FROM EMPLOYEES
START WITH MANAGER_ID IS NULL
CONNECT BY PRIOR EMPLOYEE_ID = MANAGER_ID;

```

```sql
-- SHOPPING_CATEGORIES 테이블에서 전체 계층 구조 조회
SELECT CATEGORY_ID,
				PARENT_CATEGORY_ID,
				LTRIM(SYS_CONNECT_BY_PATH(CATEGORY_NAME, '->'), '->') AS PATH,
				LEVEL
FROM SHOPPING_CATEGORIES
START WITH PARENT_CATEGORY_ID IS NULL
CONNECT BY PRIOR CATEGORY_ID = PARENT_CATEGORY_ID;				
```

| ID | Parent ID | Category | Level |
| --- | --- | --- | --- |
| 1 |  | Electronics | 1 |
| 4 | 1 | Electronics->Mobile Phones | 2 |
| 13 | 4 | Electronics->Mobile Phones->Smartphones | 3 |
| 14 | 4 | Electronics->Mobile Phones->Feature Phones | 3 |
| 5 | 1 | Electronics->Laptops | 2 |
| 15 | 5 | Electronics->Laptops->Gaming Laptops | 3 |
- 특정 루트노드 하위 항목만

```sql
-- 'Electronics'카테고리의 모든 하위 카테고리 출력
SELECT CATEGORY_ID,
				PARENT_CATEGORY_ID,
				LTRIM(SYS_CONNECT_BY_PATH(CATEGORY_NAME, '->'), '->') AS PATH,
				LEVEL
FROM SHOPPING_CATEGORIES
START WITH CATEGORY_NAME = 'Electronics'
CONNECT BY PRIOR CATEGORY_ID = PARENT_CATEGORY_ID;				
```

- 특정 레벨만 조회
    
    ```sql
    SELECT CATEGORY_ID,
    				CATEGORY_NAME,
    				LEVEL
    FROM SHOPPING_CATEGORIES
    START WITH PARENT_CATEGORY_ID IS NULL
    CONNECT BY PRIOR CATEGORY_ID = PARENT_CATEGORY_ID
    GROUP BY CATEGORY_ID, CATEGORY_NAME, LEVEL
    HAVING LEVEL = 2;				
    ```
    
    - WHERE 절은 계층쿼리 전에 수행됨. 그래서 WHERE절에서는 LEVEL을 알 수 없음.
        
        ⇒ 그래서 LEVEL 필터링은 HAVING 절에서 해야함
        
        ```sql
        SELECT CATEGORY_ID,	CATEGORY_NAME, LEVEL
        FROM SHOPPING_CATEGORIES
        WHERE LEVEL = 2
        START WITH PARENT_CATEGORY_ID IS NULL
        CONNECT BY PRIOR CATEGORY_ID = PARENT_CATEGORY_ID;
        ```
                
- 가장 하위 레벨만 조회
    - 하위 카테고리가 없는 애들 출력
    
    ```sql
    SELECT CATEGORY_ID, CATEGORY_NAME
    FROM SHOPPING_CATEGORIES
    WHERE CATEGORY_ID NOT IN (SELECT DISTINCT PARENT_CATEGORY_ID
                            FROM SHOPPING_CATEGORIES
                            WHERE PARENT_CATEGORY_ID IS NOT NULL);
    ```
    
- 각 카테고리의 부모 카테고리 이름을 함께 조회
  ```sql
  SELECT C1.CATEGORY_ID, C1.CATEGORY_NAME, 
  				C2.CATEGORY_NAME AS PARENT_CATEGORY_NAME
  FROM SHOPPING_CATEGORIES C1
  	LEFT JOIN SHOPPING_CATEGORIES C2
  		ON C1.PARENT_CATEGORY_ID = C2.CATEGORY_ID;
```
