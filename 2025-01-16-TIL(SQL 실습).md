<aside>
  ✨
  
  **TIL**
  
  - (3)  NVL 함수를 사용할 때 왼쪽 형식과 오른쪽 형식이 같아야함!
  - (20) 이름이 겹칠 것을 우려하면 앞에 JOIN을 한 번 더 하기 보다는 GROUP BY뒤에 ID와 NAME을 두고 SELECT에서 NAME만 할 수 있음!
</aside>

### 1. 직원과 부서 정보 조회

- 직원 이름과 소속 부서의 근무지를 조회

```sql
SELECT [E.NAME](http://e.name/), D.LOCATION
FROM EMPLOYEES E
INNER JOIN DEPARTMENTS D
ON D.DEPARTMENT_ID = E.DEPARTMENT_ID;
```

### 2. 직원과 매니저 정보 조회

- 직원 이름과 해당 직원의 매니저 이름 조회 - 단 매니저가 없는 직원도 출력

```sql
SELECT [S.NAME](http://s.name/) EMPLOYEE_NAME, [M.NAME](http://m.name/) MANAGER_NAME
FROM EMPLOYEES S
LEFT OUTER JOIN EMPLOYEES M
	ON S.MANAGER_ID = M.EMPLOYEE_ID;
```

### 3. 직원과 급여 정보 조회

- 직원 이름과 급여를 조회하되 급여가 NULL인 경우 "N/A" 출력

```sql
SELECT NAME, NVL(TO_CHAR(SALARY), 'N/A') SALARY
FROM EMPLOYEES;
```

### 4. 특정 부서 직원 조회

- 근무지가 Chicago인 직원 이름과 급여 조회

```sql
SELECT [E.NAME](http://e.name/), E.SALARY
FROM EMPLOYEES E
INNER JOIN DEPARTMENTS D
ON D.DEPARTMENT_ID = E.DEPARTMENT_ID
WHERE D.LOCATION = 'Chicago';
```

### 5. 특정 급여 범위 조회

- 급여가 5000이상 10000이하인 직원의 이름과 급여, 부서명 조회

```sql
SELECT E.NAME, E.SALARY, D.DEPARTMENT_NAME
FROM EMPLOYEES E
LEFT OUTER JOIN DEPARTMENTS D
    ON D.DEPARTMENT_ID = E.DEPARTMENT_ID
WHERE E.SALARY >= 5000 AND E.SALARY <= 10000;

-- 5번 문제 FROM WHERE을 사용하는 경우, 단, 급여 조건이 맞아도 부서가 없는 아이들이 안나올 수 있음.
SELECT E.NAME, E.SALARY, D.DEPARTMENT_NAME
FROM EMPLOYEES E, DEPARTMENTS D
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID
    AND E.SALARY BETWEEN 5000 AND 10000;

```

### 6. 최근 3개월 내 입사한 직원

- 최근 3개월 이내 입사한 직원 이름과 입사일을 조회하세요.

```sql
SELECT NAME, HIRE_DATE
FROM EMPLOYEES
WHERE MONTHS_BETWEEN(SYSDATE, HIRE_DATE) <= 3;발표자
SELECT NAME< HIRE_DATE
FROM EMPLOYEES
WHERE HIRE_DATE >= SYSDATE - (INTERVAL '3' MONTH);

-- ADDMONTH, MONTHS_BETWEEN 사용
```

### 7. 부서장 이름 조회

- 각 부서의 부서장 이름과 부서 이름을 조회하세요

```sql
SELECT D.DEPARTMENT_NAME, E.NAME
FROM DEPARTMENTS D
LEFT OUTER JOIN EMPLOYEES E
    ON D.MANAGER_ID = E.EMPLOYEE_ID;

-- 부서가 있음에도 부서장이 없을 수 있기 때문에 LEFT OUTER JOIN 사용!
```

### 8. 직무별 직원 수 조회

- 직무별 직원 수를 출력하세요.

```sql
SELECT JOB_ID, COUNT(*) COUNT
FROM EMPLOYEES
GROUP BY JOB_ID;

```

### 9. 부서별 평균 급여

- 부서명과 부서별 평균 급여를 조회하세요. (단, 평균 급여는 올림하여 출력)

```sql
SELECT D.DEPARTMENT_NAME, CEIL(AVG(SALARY)) AVG_SALARY
FROM EMPLOYEES E, DEPARTMENTS D
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID
GROUP BY DEPARTMENT_NAME;

```

### 10. 직원의 총 급여 합계

- 직원의 총 급여 합계를 조회하세요. 넵

```sql
SELECT SUM(SALARY)
FROM EMPLOYEES;

```

### 11. 대출 정보와 고객 이름 조회

- 대출 금액과 고객 이름을 대출 금액이 높은 사람부터 조회하세요.

```sql
SELECT C.NAME, L.AMOUNT
FROM CUSTOMERS C, LOANS L
WHERE C.CUSTOMER_ID = L.CUSTOMER_ID
ORDER BY L.AMOUNT DESC;

```

### 12. 대출 상태별 고객 수

- 대출 상태별 고객 수를 조회하세요.

```sql
SELECT STATUS, COUNT(DISTINCT CUSTOMER_ID) CUSTOMER_COUNT
FROM LOANS
GROUP BY STATUS;

```

### 13. 직원 수가 가장 적은 부서

- 직원 수가 가장 적은 부서의 부서 ID와 직원수를 조회하세요.

```sql
	-- 하나만 고르기
SELECT DEPARTMENT_ID, COUNT
FROM (SELECT ROW_NUMBER() OVER(ORDER BY COUNT(*)) AS ROW_NUM, 
						 D.DEPARTMENT_ID, COUNT(*) COUNT 
        FROM EMPLOYEES E, DEPARTMENTS D
        WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID
        GROUP BY D.DEPARTMENT_ID)
WHERE ROW_NUM=1;

	-- 최솟값 모두 고르기
SELECT D.DEPARTMENT_ID, COUNT(*) 
FROM EMPLOYEES E, DEPARTMENTS D
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID
GROUP BY D.DEPARTMENT_ID
HAVING COUNT(*) = (SELECT MIN(EMPLOYEES)
                    FROM (SELECT D.DEPARTMENT_ID, COUNT(*) EMPLOYEES
                            FROM EMPLOYEES E, DEPARTMENTS D
                            WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID
                            GROUP BY D.DEPARTMENT_ID));

```

### 14. 월별 신규 고객 수

- 월별 신규 고객 수를 최근순으로 조회하세요.

```sql
SELECT TO_CHAR(CREATED_AT, 'YYYY-MM') MONTH, COUNT(*) NEW_CUSTOMERS
FROM CUSTOMERS
GROUP BY TO_CHAR(CREATED_AT, 'YYYY-MM')
ORDER BY MONTH DESC;

```

### 15. 상품 카테고리 계층 구조 조회

- 상품 카테고리와 상위 카테고리를 조회하세요.(단, 상위 카테고리가 없는 데이터도 출력)

```sql
SELECT C.CATEGORY_NAME CATEGORY, P.CATEGORY_NAME PARENT_CATEGORY
FROM SHOPPING_CATEGORIES C
LEFT OUTER JOIN SHOPPING_CATEGORIES P
    ON C.PARENT_CATEGORY_ID = P.CATEGORY_ID;
    
```

### 16. 특정 지점의 대출 합계

- 'Branch 8' 지점의 대출 총합을 조회하세요. (단, 소수점 아래는 버림)

```sql
SELECT B.NAME BRANCH_NAME, FLOOR(SUM(L.AMOUNT)) TOTAL_AMOUNT
FROM BRANCHES B, LOANS L
WHERE B.BRANCH_ID = L.BRANCH_ID
GROUP BY B.NAME
HAVING B.NAME = 'Branch 8';
```

### 17. 직무별 직원의 평균 급여와 급여 등급 조회

- 직무별 직원의 평균 급여를 계산하여 평균 급여가 5000 이상인 경우만 출력합니다.
    - 평균 급여가 8000 이상인 경우 "HIGH",
    - 6000 이상 8000 미만인 경우 "MEDIUM",
    - 6000 미만인 경우 "LOW"로 표시합니다.
    - 결과는 평균 급여가 높은 순으로 정렬하세요.

```sql
SELECT JOB_ID, CASE 
            WHEN AVG(SALARY) >= 8000 THEN 'HIGH'
            WHEN AVG(SALARY) >= 6000 THEN 'MEDIUM'
            ELSE 'LOW'
        END AS SALARY_LEVEL
FROM EMPLOYEES
GROUP BY JOB_ID
HAVING AVG(SALARY) >= 5000;

```

### 18. 고객별 거래 내역

- 고객 이름과 거래 내역(금액)을 조회하여 고객 이름으로 오름차순 하세요.

```sql
SELECT C.NAME, T.TOTAL_AMOUNT
FROM CUSTOMERS C, (SELECT A.CUSTOMER_ID, SUM(T.AMOUNT) TOTAL_AMOUNT
                    FROM ACCOUNTS A, TRANSACTIONS T
                    WHERE A.ACCOUNT_ID = T.ACCOUNT_ID
                    GROUP BY A.CUSTOMER_ID) T
WHERE C.CUSTOMER_ID = T.CUSTOMER_ID
ORDER BY C.CUSTOMER_ID;

```

### 19. 부서별 직원의 평균 입사일 차이

- 부서별로 평균 근속일을 계산하여 부서이름으로 오름차순 정렬하세요. 
(단, 평균 근속일은 반올림하여 정수로 표현)

```sql
SELECT DEPARTMENT_ID, ROUND(AVG((SYSDATE - HIRE_DATE))) WORKED
FROM EMPLOYEES
GROUP BY DEPARTMENT_ID
ORDER BY WORKED;

```

### 20. 대출 금액 상위 5명 고객 조회

- 대출 금액이 가장 높은 상위 5명의 고객의 이름과 대출 금액을 조회하세요.
(단, 대출 금액이 동일한 경우 고객의 이름으로 오름차순)

```sql
-- 지현
SELECT *
FROM (SELECT C.NAME, SUM(L.AMOUNT) TOTAL_AMOUNT 
        FROM LOANS L, CUSTOMERS C
        WHERE C.CUSTOMER_ID = L.CUSTOMER_ID
        GROUP BY C.NAME, C.CUSTOMER_ID
        ORDER BY TOTAL_AMOUNT DESC, C.NAME)
WHERE ROWNUM <=5;

```
