# Paging Query

> 대량의 데이터에서 일정한 크기로 데이터를 나누어 보여주는 방법
> 
- 성능 최적화와 사용자 경험 개선을 위해 중요

### `ROWNUM`

오라클에서 결과 집합의 각 행에 부여되는 번호, 슈도 컬럼

⇒ 넘버링해서 숫자별로 자름  - 페이징

얘는 ORDER BY 넣으면 기존(랜덤 출력 기준) ROWNUM이 나와서

### `ROW_NUMBER()`

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/93168b73-e0b5-48df-bb63-8f8bf0a550fe/068d154c-f170-45d5-8677-bbf28d715690/image.png)

```sql
ROW_NUMBER( )
OVER ([ query_partition_clause ] order_by_clause)

SELECT * FROM (
	SELECT ROWNUM AS row_num, column_list
	FROM table_name
	WHERE ROWNUM <=:end_row
)
WHERE row_num >= :start_row;

SELECT ROWNUM, COL_LIST -- 그걸 
FROM ( 
	SELECT ROWNUM AS row_num, column_list
	FROM table_name
	WHERE ROWNUM <=:end_row 
	ORDER BY REG_DATE DESC -- 게시일 기준으로 내림차순 하고
)
WHERE ROWNUM BETWEEN 1 AND 10;

SELECT * FROM (
	SELECT ROW_NUMBER() 
	OVER (ORDER BY column_name) AS row_num, column_list
	FROM table_name
)
WHERE row_num BETWEEN :start_row AND :end_row;
```

오라클 윈도우 함수로, 정렬 기준에 따라 고유 번호를 부여

- 일반적으로 게시글은 게시일 DESC
- 바깥에서 넘버링 조건을 주는게 맞음.
- 안쪽에서 오더바이 하고 바깥쪽에서 넘버링.

<aside>
✨

SELECT 작동 순서

- FROM
- WHERE
- GROUP BY
- HAVING
- SELECT
- ORDER BY
</aside>

<aside>
✨

**OFFSET-FETCH**

```sql
SELECT column_list
FROM table_name
OREDER BY some_column
OFFSET :start_row-1 ROWS FETCH NEXT : page_size ROWS ONLY;
```

- `OFFSET :start_row-1 ROWS` : 시작위치 지정
- `:start_row` : 조회를 시작할 첫번째 행 번호
- `FETCH NEXT :page_size ROWS ONLY` : 가져올 행 수 지정
</aside>

# `DISTINCT`

중복 데이터 제거하여 고유한 값만 반환

- SELECT 절의 모든 컬럼에 영향

`SELECT DISTINCT column_name
 FROM table_name;`

# `GROUP BY`

SELECT 문에서 데이터 그룹핑

그룹별 집계 결과 반환

WHERE 절과 함께 사용 가능

- WHERE 절은 GROUP BY 전에 조건 필터링

`SELECT column_name, func() 
 FROM table_name
 GROUP BY column_name;`

## `HAVING`

GROUP BY 이후 그룹별 조건 필터링

그룹핑이 되고 나서 조건 줌

→ WHERE 절에 줄 수 없는 조건

- 그렇다면 WHERE 절 조건을 HAVING이 할 수 있을까
    
    가능한. 근데 비효율적. 조건을 안 쳐내고 그룹핑 해놓고 조건 거는 거임.
    
    ⇒ WHERE 절에 쓸 수 있는 건 다 WHERE에 쓰는게 좋음
    
- 집계함수 ALIAS를  GROUP BY에 쓸 수 있나?
    
    없다. GROUP BY가 SELECT보다 먼저 실행되기 때문
    
    - 같은 이유료 ORDER BY에서는 쓸 수 있음.
        
        SELECT가 ORDER BY보다 먼저 실행
        

## Aggregate Function

### `COUNT()`

- 안에 *, 1, col_name
    - 집계함수는 세로로 계산 → null 을 빼고 아닌 애들을 계산
        - *, 1가 있으면 null까지 모두 포함.
- DISTINCT col → 중복값 제거한 상태로 계산

### `SUM()`

### `AVG()`

### `MAX()`

### `MIN()`

# Function

## Single-Row Functions

한 행에 대해 하나의 결과 반환

## Character Functions

문자열 변환 및 처리

### `UPPER()` / `LOWER()`

- 검색어 입력 받을 때, 회원 아이디 중복 검사

```sql
SELECT UPPER('hello') AS UPPERCASE, 
        LOWER('WORLD') AS LOWERCASE
FROM DUAL;
```

| UPPERCASE | LOWERCASE |
| --- | --- |
| HELLO | world |

### `LENGTH()` / `SUBSTR()`

`SUBSTR(*string*, :start, :end)`

```sql
SELECT LENGTH('SQL Function') AS LENGTH,
        SUBSTR('SQL Function', 5, 8) AS SUBSTRING
FROM DUAL;
```

| LENGTH | SUBSTRING |
| --- | --- |
| 12 | Function |

### `INSTR()` / `TRIM()`

```sql
SELECT INSTR('Oracle SQL', 'SQL') AS POSITION,
        TRIM('Oracle SQL') AS TRIMMED_STRING
FROM DUAL;
```

| POSITION | TRIMMED_STRING |
| --- | --- |
| 8 | Oracle SQL |

`RTRIM`/`LTRIM`

```sql
SELECT INSTR('Oracle SQL', 'SQL') AS POSITION,
        RTRIM('Oracle SQL ', 'SQL') AS TRIMMED_STRING
FROM DUAL;

```

| POSITION | TRIMMED_STRING |
| --- | --- |
| 8 | Oracle SQL |

```sql
SELECT INSTR('Oracle SQL', 'SQL') AS POSITION,
        RTRIM('Oracle SQL', 'SQL') AS TRIMMED_STRING
FROM DUAL;
```

| POSITION | TRIMMED_STRING |
| --- | --- |
| 8 | Oracle |

### `LPAD()` / `RPAD()`

```sql
SELECT LPAD('SQL', 10, '*') AS LEFT_PADDED,
        RPAD('SQL', 10, '*') AS RIGHT_PADDED
FROM DUAL;
```

| LEFT_PADDED | RIGHT_PADDED |
| --- | --- |
| *******SQL | SQL******* |

### `REPLACE()` / `CONCAT()`

```sql
SELECT REPLACE('Hello SQL', 'SQL', 'Oracle') AS REPLACED_STRING, 
        CONCAT('Hello', 'World') AS CONCATENATED_STRING
FROM DUAL;

SELECT REPLACE('Hello SQL', 'SQL', 'Oracle') AS REPLACED_STRING, 
        'Hello'||'World' AS CONCATENATED_STRING
FROM DUAL;
```

| REPLACED_STRING | REPLACED_STRING |
| --- | --- |
| Hello Oracle | HelloWorld |

## Numeric Functions

수학적 계산

### `ROUND()` / `TRUNC()`

반올림 / 내림(자르기)

```sql
SELECT ROUND(123.456, 2) AS ROUNDED, TRUNC(123.456, 2) AS TRUNCATED
FROM DUAL;
```

| ROUNDED | TRUNCATED |
| --- | --- |
| 123.46	 | 123.45 |
- 음수 ROUND는 절댓값 반올림에 마이너스 붙임

### `CEIL()` / `FLOOR()`

올림 / 버림

```sql

```

### `ABS()` / `MOD()`

절대값과 나머지 계산

```sql
SELECT ABS(-123) AS ABSOLUTE, MOD(10, 3) AS REMAINDER
FROM DUAL;
```

| ABSOLUTE | REMAINDER |
| --- | --- |
| 123	 | 1 |

## Datetime Functions

날짜 함수

### `SYSDATE` / `CURRENT_DATE`

현재 날짜와 시간 반환

- UPDATE나 INSERT 문에서 SYSDATE 자주 등장

```sql
SELECT SYSDATE AS CURRENT_DATE, CURRENT_DATE AS SESSION_DATE
FROM DUAL;
```

| CURRENT_DATE | SESSION_DATE |
| --- | --- |
| 25/01/15 | 25/01/15 |

### `ADD_MONTHS()` / `MONTHS_BETWEEN()`

```sql
SELECT ADD_MONTHS(SYSDATE, 2) AS TWO_MONTHS_LATER, 
        MONTHS_BETWEEN(
        SYSDATE, TO_DATE('2024-01-01', 'YYYY-MM-DD')) AS MONTH_DIFF
FROM DUAL;
```

| TWO_MONTHS_LATER | MONTH_DIFF |
| --- | --- |
| 25/03/15 | 12.47125410692951015531660692951015531661 |

### `NEXT_DAY()` / `LAST_DAY()`

```sql
SELECT NEXT_DAY(SYSDATE, '일요일') AS NEXT_SUNDAY,
        LAST_DAY(SYSDATE) AS END_OF_MONTH
FROM DUAL;
```

| NEXT_SUNDAY | END_OF_MONTH |
| --- | --- |
| 25/01/19 | 25/01/31 |

### `EXTRACT()` / `TRUNC()`

```sql
SELECT EXTRACT(YEAR FROM SYSDATE) AS CURRENT_YEAR,
        TRUNC(SYSDATE, 'MM') AS START_OF_MONTH
FROM DUAL;
```

| CURRENT_YEAR | START_OF_MONTH |
| --- | --- |
| 2025 | 25/01/01 00:00:00 |

## Conversion Functions

변환 함수

### `TO_CHAR()`

### `TO_DATE()`

### `TO_NUMBER()`

```sql
SELECT TO_CHAR(SYSDATE, 'YYYY-MM-DD') AS DATE_STRING,
        TO_DATE('2025-01-15', 'YYYY-MM-DD') AS DATE_VALUE,
        TO_NUMBER('1234') AS NUMERIC_VALUE
FROM DUAL;
```

| DATE_STRING | DATE_VALUE | NUMERIC_VALUE |
| --- | --- | --- |
| 2025-01-15 | 25/01/15 00:00:00 | 1234 |

## NULL-Related Functions

NULL 값 처리

### `NVL()` / `NVL2()`

NULL 값 대체 / NULL 여부에 따라 다른 값 반환

```sql
SELECT NVL(NULL,'Default Value') AS NVL_RESULT,
        NVL2(NULL, 'Not Null', 'Null') AS NVL2_RESULT,
        NVL2('0','Not Null', 'Null') AS NVL2_RESULT
FROM DUAL;
```

| NVL_RESULT | NVL2_RESULT | NVL2_RESULT |
| --- | --- | --- |
| Default Value | Null | Not Null |

### `COALESCE()`

NULL이 아닌 첫번째 값 반환

```sql
SELECT COALESCE(NULL,'Not Null', 'First Non-Null') AS RESULT
FROM DUAL;
```

| RESULT |
| --- |
| Not Null |

### `NULLIF()`

두 값이 같으면 NULL 반환

```sql
SELECT NULLIF(1, 1) AS RESULT
FROM DUAL;
```

| RESULT |
| --- |
| (null) |

# `CASE WHEN`

조건에 따라 값을 반환하는 문법

분기 처리

- 조건 처리에 유연
- 여러 조건 및 복잡한 로직 처리 가능

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/93168b73-e0b5-48df-bb63-8f8bf0a550fe/24f04635-67ff-4ebf-a0f5-2524ac6bf304/image.png)

- simple case expression

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/93168b73-e0b5-48df-bb63-8f8bf0a550fe/73d361e9-9420-4457-a48d-dc3ee1365347/image.png)

only equal

```sql
CASE column_name
	WHEN value1 THEN result1
	WHEN value2 THEN result2
	ELSE result
END
```

- searched case expression

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/93168b73-e0b5-48df-bb63-8f8bf0a550fe/f4493225-3bdb-42d6-82f1-e357ceab6488/image.png)

```sql
CASE 
	WHEN condition1 THEN result1
	WHEN condition2 THEN result2
	ELSE result
END
```

# `DECODE`

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/93168b73-e0b5-48df-bb63-8f8bf0a550fe/b0c5109e-b90d-4eac-b517-00c0404d9940/image.png)

simple case expression 은 DECODE로 가능

- 간단한 값 매핑에 적합
- 특정 열 값 기반으로 처리
  ```sql
  SELECT EMPLOYEE_ID,
          DECODE(JOB_ID,
              'ADMIN', '관리자',
              'DEV', '개발자',
              'HR', '인사담당자',
              '기타') AS DEPARTMENT_NAME
  FROM EMPLOYEES;
```

# JOIN

여러 테이블의 데이터를 결합하여 하나의 결과 집합을 생성하는 SQL 절

- 기본적으로 두 개 이상의 테이블 연결
- 테이블 간 관계를 활용하여 데이터 조회
- 데이터의 일관성과 중복 방지를 위해 데이터를 여러 테이블로 나누어 저장 - 정규화
- 나누어진 데이터를 조합하여 원하는 정보 조회

🚧

- JOIN 조건 누락
- NULL 처리 - OUTER JOIN 시
- 큰 테이블 간 JOIN은 성능 저하 가능. 적절한 인덱스 설정 필요

### INNER JOIN

두 테이블 간 일치하는 데이터만 반환

기본적인 JOIN 방식

```sql
SELECT E.NAME, D.DEPARTMENT_NAME
FROM EMPLOYEES E
INNER JOIN DEPARTMENTS D
    ON E.DEPARTMENT_ID = D.DEPARTMENT_ID;
```

### OUTER JOIN

FROM 절 테이블이 LEFT TABLE

JOIN 문 안 테이블이 RIGHT TABLE

일치하지 않는 경우 NULL 반환

- LEFT OUTER JOIN
    
    LEFT TABLE 기준으로 RIGHT TABLE이 붙음
    
    ```sql
    SELECT E.NAME, D.DEPARTMENT_NAME
    FROM EMPLOYEES E
        LEFT OUTER JOIN DEPARTMENTS D
            ON E.DEPARTMENT_ID = D.DEPARTMENT_ID;
    ```
    
- RIGHT OUTER JOIN
    
    ```sql
    SELECT E.NAME, D.DEPARTMENT_NAME
    FROM EMPLOYEES E
        RIGHT OUTER JOIN DEPARTMENTS D
            ON E.DEPARTMENT_ID = D.DEPARTMENT_ID;
    ```
    
- FULL OUTER JOIN
    
    ```sql
    SELECT E.NAME, D.DEPARTMENT_NAME
    FROM EMPLOYEES E
        FULL OUTER JOIN DEPARTMENTS D
            ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
    ORDER BY D.DEPARTMENT_ID;
    ```
    

### SELF JOIN

같은 테이블 두번 사용

주로 계층 구조 표현할 때 사용

```sql
SELECT E1.NAME AS EMPLOYEE, E2.NAME AS MANAGER
FROM EMPLOYEES E1
    JOIN EMPLOYEES E2
        ON E1.MANAGER_ID = E2.EMPLOYEE_ID;
```

### CROSS JOIN

두 테이블 간 모든 행의 조합을 반환 - CARTESIAN PRODUCT

JOIN 조건이 없는 경우 발생

결과값 엄청 많을 수도 있으니 주의!

```sql
SELECT E.NAME, D.DEPARTMENT_NAME
FROM EMPLOYEES E
CROSS JOIN DEPARTMENTS D;
```

### NATURAL JOIN

동일한 이름의 컬럼을 기준으로 JOIN

조건을 명시하지 않아도 자동으로 연결

이런게 잇긴 하다~ 하지만 실무에선 딱히

```sql
SELECT NAME, DEPARTMENT_NAME
FROM EMPLOYEES E
NATURAL JOIN DEPARTMENTS D;
```

## 내부 작동 JOIN

- NEST LOOP JOIN
    - 중첩 구문 for i { for j {} }
- SORT MERGE JOIN
- HASH JOIN

OLTP 쿼리에서는 NL JOIN이 좋다 -
