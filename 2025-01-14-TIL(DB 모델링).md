# 정규화

> 데이터베이스의 설계 단계에서 데이터 중복을 제거하고 데이터 무결성을 유지하기 위한 과정
> 
- 데이터를 **논리적으로 분리**하여 효율적으로 저장하고 관리하도록 설계
- Data Transaction

### 1NF

- 모든 속성은 반드시 하나의 값만 가짐 - Atomic Value
- 유사한 속성이 반복되지 않아야함 - Non-Repeating groups

비정규형 테이블:

| 학생ID | 학생명 | 강의1 | 강의2 | 강의3 |
| --- | --- | --- | --- | --- |
| 101 | 홍길동 | 수학 | 영어 | 과학 |
| 102 | 김영희 | 수학 | 영어 | NULL |

1NF로 변환:

| 학생ID | 학생명 | 강의명 |
| --- | --- | --- |
| 101 | 홍길동 | 수학 |
| 101 | 홍길동 | 영어 |
| 101 | 홍길동 | 과학 |
| 102 | 김영희 | 수학 |
| 102 | 김영희 | 영어 |

### 2NF

엔티티의 모든 일반 속성은 반드시 모든 주식별자에 종속 되어야 함

- 만약에 주식별자가 2개 이상인 경우 → 일반속성이 이 둘에 모두 종속되지 않는다면 정규화가 필요함
- 기본키의 부분적 종속이 없어야 함(모든 비-키 속성이 기본키 전체에 종속).
- 새로운 음료를 추가하는 경우 삽입 이상 생길 수 있음
    - 나머지 속성이 null이어야함
- 삭제이상도 생김
    - 다른 속성도 지워야함

⇒ 상품 마스터 테이블 만들어야함

### 1NF 테이블:

| 학생ID | 학생명 | 강의명 | 교수명 |
| --- | --- | --- | --- |
| 101 | 홍길동 | 수학 | 김철수 |
| 101 | 홍길동 | 영어 | 이영희 |
| 102 | 김영희 | 수학 | 김철수 |

### 문제:

- `학생명`은 `학생ID`에만 종속(부분적 종속).

### 2NF로 변환:

**학생 테이블:**

| 학생ID | 학생명 |
| --- | --- |
| 101 | 홍길동 |
| 102 | 김영희 |

**강의 테이블:**

| 강의명 | 교수명 |
| --- | --- |
| 수학 | 김철수 |
| 영어 | 이영희 |

**수강 테이블:**

| 학생ID | 강의명 |
| --- | --- |
| 101 | 수학 |
| 101 | 영어 |
| 102 | 수학 |

### 3NF

주식별자가 아닌 모든 속성 간에는 서로 종속 될 수 없음

- 일반속성끼리 종속이 되어있는 경우
- 비-키 속성이 다른 비-키 속성에 이행적 종속이 없어야 함.

### 2NF 테이블:

| 강의명 | 교수명 | 교수실 |
| --- | --- | --- |
| 수학 | 김철수 | A101 |
| 영어 | 이영희 | B202 |

### 문제:

- `교수실`은 `교수명`에 종속되어 있음(이행적 종속).

### 3NF로 변환:

**강의 테이블:**

| 강의명 | 교수명 |
| --- | --- |
| 수학 | 김철수 |
| 영어 | 이영희 |

**교수 테이블:**

| 교수명 | 교수실 |
| --- | --- |
| 김철수 | A101 |
| 이영희 | B202 |

---

주문번호

주문 상품 코드

회원번호

주문상품명

주문상품가격

결제수단 

배송지 번호

⇒ 2정규화 위배

## Denormalization

데이터베이스 설계에서 정규화를 통해 분리된 테이블을 특정 성능 향상이나 시스템 요구에 따라 다시 결합하거나 중복 데이터를 허용하는 과정

성능 최적화와 효율적인 데이터 액세스를 위해 데이터 모델을 조정하는 것

- 정규화의 한계
    - 다수 테이블 조인 필요한 경우에는 성능 저하 발생 가능
- 성능 최적화
    - 쿼리 성능 개선을 위해 데이터를 중복 저장하거나 테이블을 합치는 방식으로 읽기 속도 높임
    - OLAP에서 주로 사용
- 중복 데이터 저장 (파생컬럼)
- 속성 추가
- 테이블 병합
- 이력 데이터 관리
    - 과거 데이터 효율적 조회
        - 직전 비밀번호와 새 비밀번호가 같으면 안됨

### 장점

- 성능 개선
- 간단한 쿼리
- 특정 요구사항 대응

### 단점

- 데이터 중복
- 데이터 무결성 문제
- 유연성 감소

배송조회 테이블에 회원번호를 넣기,,

# 데이터처리

## OLTP (Online Transaction Processing)

실시간으로 다수의 트랜잭션 처리하는 시스템

- 주로 운영환경에서 사용
- 데이터 입력, 저장, 수정, 조회 빠르게 처리
- 은행 시스템, 전자상거래, 예약 시스템

### 특징

- 실시간 처리
- 정규화된 데이터 구조
    
    데이터 중복 최소화 및 데이터 무결성 유지
    
- 트랜잭션 관리: ACID

### 구성요소

- RDBMS
- 웹 또는 모바일 기반 트랜잭션 처리 애플리케이션
- 실시간으로 데이터 입력/조회하는 최종 사용자

## OLAP (Online Analytical Processing)

대규모 데이터를 분석하고, 요약 정보와 통찰력을 제공하는 시스템

- 데이터 분석, 보고서 생성, 비즈니스 인사이트 제공
- 데이터 마트, BI, 대시보드 시스템

### 특징

- 복잡한 분석
    
    집계, 요약, 패턴 분석 쿼리를 통해 비즈니스 인사이트 제공
    
- 대규모 데이터 처리
    
    데이터 웨어하우스 및 데이터 마트를 활용하여 분석
    
- 다차원 데이터 분석
    
    시간, 지역, 제품 등 여러 차원을 기준으로 데이터 요약
    

### 구성 요소

- 데이터 웨어하우스
    
    정형, 비정형 데이터를 통합하고 분석 중심으로 저장
    
- OLAP 서버: 분석 쿼리를 실행하며 다차원 데이터 모델 제공
- 사용자 인터페이스: 분석 결과를 시각적으로 제공하는 대시보드와 리포트

### OLTP ↔ OLAP

- OLTP 시스템 - 데이터 생성
- OLAP 시스템 - 데이터 활용
- ETL 프로세스: 데이터 웨어하우스로 데이터를 전송하기 위해 사용
    
    Extract, Transform, Load
    

OLTP → ETL → OLAP

# 데이터 모델링

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/93168b73-e0b5-48df-bb63-8f8bf0a550fe/fd96eec4-b811-4e24-b8c5-29331885f045/36a4b112-9ca5-4e36-8222-e024d050f0bf.png)

### 논리모델

데이터의 구조와 관계를 기술하는 모델

- entity/attribute 정의
- Relationship과 제약 조건 표현
- 데이터 중복 제거를 위한 정규화 적용

### 물리모델

특정 DBMS에 종속적인 데이터 구조 정의하는 모델 - 최종 단계

- 데이터 저장소, 성능, 보안을 고려하여 실제 구현
- 데이터 타입과 제약 조건 지정
- 인덱스, 파티션, 저장소 구조 설계
- DBMS의 기술적 제약 및 성능 최적화 반영

# Transaction

데이터베이스에서 하나의 논리적 작업 단위

- 일련의 작업이 모두 성공하거나 실패하는 것을 보장
- 트랜잭션은 데이터 무결성과 일관성을 유지하기 위한 기본 단위로 사용

### 유의 사항

- 작업단위 명확히 정의
    
    트랜잭션 범위 좁게 설계하여 성능과 오류 가능성 최소화
    
- 최소한의 데이터 변경
    
    필요 이상의 데이터를 수정하거나 삭제하지 않도록 제한
    
- 장기 트랜잭션 방지
    
    트랜잭션이 너무 오래 실행되지 않도록 설계하여 데이터베이스 Lock 문제 방지
    
- 적절한 격리 수준 설정
    
    시스템 성능과 데이터 정확성 간 균형 유지
    

## ACID

### Atomicity

모두다 성공하거나 모두 실패하거나 - all or nothing

- 실패 시 모든 변경 사항을 ROLLBACK하여 원상태로 복구
    - 계좌 이체에서 송금과 입금 작업 중 하나라도 실패하면 전체 트랜잭션이 취소

### Consistency

**성공**했을 때(트랜잭션이 완료된 후) DB는 항상 일관되게 유지

- 데이터 무결성 보장
    - DB의 모든 외래키 관계가 트랜잭션 이후에도 유지

### Isolation

서로 다른 세션끼리 끼어들지 않게 독립적으로 처리

- 트랜잭션 격리 수준으로 구현
    <details>
    <summary>Isolation Level</summary>
    
    **트랜잭션 격리 수준 (Isolation Level)**
      데이터베이스에서 트랜잭션이 서로 간섭하지 않도록 보장하는 방법을 정의합니다. 이는 여러 트랜잭션이 동시에 실행될 때 데이터의 일관성과 무결성을 유지하기 위해 중요합니다.
                
        ### 4가지 격리 수준 (0~3으로 표현)
        
        1. **Read Uncommitted (격리 수준 0)**
            - **가장 낮은 격리 수준**으로, 다른 트랜잭션이 아직 커밋되지 않은 데이터를 읽을 수 있습니다. 즉, **더티 읽기(Dirty Read)**가 발생할 수 있습니다.
            - **문제점**: 한 트랜잭션이 수정한 데이터를 다른 트랜잭션이 읽을 수 있으며, 수정이 롤백되면 읽은 데이터는 잘못된 값이 됩니다.
            - **예시**: 트랜잭션 A가 데이터를 수정하고 커밋하지 않은 상태에서 트랜잭션 B가 그 데이터를 읽을 수 있습니다.
        2. **Read Committed (격리 수준 1)**
            - **커밋된 데이터만 읽을 수 있는 수준**입니다. 즉, 다른 트랜잭션이 커밋한 데이터만 읽을 수 있고, 아직 커밋되지 않은 데이터는 읽을 수 없습니다.
            - **문제점**: **비 반복적 읽기(Non-repeatable Read)**가 발생할 수 있습니다. 즉, 트랜잭션이 데이터를 읽은 후, 다른 트랜잭션이 그 데이터를 수정하거나 삭제하면 읽은 데이터가 바뀌게 됩니다.
            - **예시**: 트랜잭션 A가 데이터를 읽고, 트랜잭션 B가 그 데이터를 수정한 후 트랜잭션 A가 다시 읽을 때, 값이 달라질 수 있습니다.
        3. **Repeatable Read (격리 수준 2)**
            - **한 트랜잭션이 읽은 데이터는 다른 트랜잭션에 의해 변경될 수 없도록 보장**합니다. 즉, **비 반복적 읽기** 문제를 해결합니다.
            - **문제점**: **팬텀 리드(Phantom Read)** 문제가 발생할 수 있습니다. 트랜잭션이 데이터를 읽은 후, 다른 트랜잭션이 새로운 데이터를 삽입하거나 삭제할 수 있습니다. 트랜잭션 A가 범위 내의 데이터를 읽은 후, 트랜잭션 B가 데이터를 삽입하여 A의 범위에 새로운 데이터가 나타날 수 있습니다.
            - **예시**: 트랜잭션 A가 특정 범위의 데이터를 읽고, 트랜잭션 B가 그 범위에 새로운 데이터를 삽입한 후, 트랜잭션 A가 다시 범위 내 데이터를 읽을 때 새로운 데이터가 포함될 수 있습니다.
        4. **Serializable (격리 수준 3)**
            - **가장 높은 격리 수준**으로, 트랜잭션이 마치 순차적으로 실행되는 것처럼 보장합니다. 즉, 다른 트랜잭션이 트랜잭션의 결과에 영향을 미칠 수 없습니다.
            - **문제점**: **팬텀 리드**를 포함한 모든 문제를 해결하지만, 성능이 가장 낮습니다. 다른 트랜잭션이 데이터를 삽입, 삭제 또는 업데이트하려고 할 때 트랜잭션이 잠겨 다른 트랜잭션이 실행되지 않도록 막습니다.
            - **예시**: 트랜잭션 A가 범위 내의 데이터를 읽고, 트랜잭션 B가 그 범위에 새로운 데이터를 삽입할 수 없으며, 트랜잭션 A가 다시 데이터를 읽을 때 데이터가 변하지 않습니다.
        
        ### 격리 수준 간의 비교
        
        | 격리 수준 | 더티 읽기 | 비 반복적 읽기 | 팬텀 읽기 |
        | --- | --- | --- | --- |
        | **Read Uncommitted** | 가능 | 가능 | 가능 |
        | **Read Committed** | 불가능 | 가능 | 가능 |
        | **Repeatable Read** | 불가능 | 불가능 | 가능 |
        | **Serializable** | 불가능 | 불가능 | 불가능 |
        
        ### 요약
        
        - **Read Uncommitted (0)**: 가장 낮은 격리 수준, 다른 트랜잭션의 미완료 데이터를 읽을 수 있음.
        - **Read Committed (1)**: 커밋된 데이터만 읽을 수 있으며, 비 반복적 읽기 문제가 발생할 수 있음.
        - **Repeatable Read (2)**: 트랜잭션이 읽은 데이터는 다른 트랜잭션에 의해 변경될 수 없으나, 팬텀 리드가 발생할 수 있음.
        - **Serializable (3)**: 가장 높은 격리 수준, 모든 트랜잭션이 순차적으로 실행되는 것처럼 보장하여 다른 트랜잭션이 영향을 미치지 않음.
        
        각 격리 수준은 성능과 일관성 사이에서 적절한 균형을 맞춰야 합니다. 높은 격리 수준일수록 트랜잭션이 더 많이 대기하게 되어 성능에 영향을 미칠 수 있습니다.
        
    </details>
       
- 한 트랜잭션이 수정 중인 데이터를 다른 트랜잭션이 볼 수 없음

재고는 1개, 사려는 소비자는 2. 이런 거 방지

- lock
    
    

### Durability

데이터가 지속되는 거 보장

- 시스템 장애 후에도 데이터는 유지
    - 트랜잭션이 COMMIT된 후 디스트에 기록된 데이터는 손실되지 않음

# 금융 시스템

# SQL 개념

## DDL (Data Definition Language)

데이터베이스 구조 정의

- 데이터 베이스 객체를 정의하거나 변경

### CREATE

테이블, 뷰, 인덱스 생성

- not null 너무 많아도 안 좋다 - 지양하는 편
    - 오류날까바.,, → 크리티컬한 거에만 넣기 일단..
    
    ```sql
    CREATE TABLE CUSTOMERS (
        CUSTOMER_ID   NUMBER(10)      PRIMARY KEY,  -- 고객 고유 ID
        FIRST_NAME    VARCHAR2(50)    NOT NULL,     -- 이름
        LAST_NAME     VARCHAR2(50)    NOT NULL,     -- 성
        EMAIL         VARCHAR2(100),               -- 이메일
        PHONE         VARCHAR2(20),                -- 전화번호
        ADDRESS       VARCHAR2(200),               -- 주소
        CITY          VARCHAR2(50),                -- 도시
        STATE         VARCHAR2(50),                -- 주/도
        ZIP_CODE      VARCHAR2(10),                -- 우편번호
        COUNTRY       VARCHAR2(50),                -- 국가
        CREATED_AT    DATE            DEFAULT SYSDATE, -- 생성일
        UPDATED_AT    DATE            DEFAULT SYSDATE  -- 수정일
    );
    
    ```
    

### ALTER

기존 객체 수정

- 컬럼 추가
    
    ```sql
    ALTER TABLE CUSTOMERS 
    ADD GENDER CHAR(1);  -- 성별 컬럼 추가 (M/F)
    ```
    
- 컬럼 사이즈/데이터 타입 변경
    
    ```sql
    -- 1. EMAIL 컬럼 크기 변경 (VARCHAR2(100) → VARCHAR2(150))
    ALTER TABLE CUSTOMERS 
    MODIFY EMAIL VARCHAR2(150);
    
    -- 2. PHONE 컬럼 데이터 타입 변경 (VARCHAR2 → NUMBER)
    ALTER TABLE CUSTOMERS 
    MODIFY PHONE NUMBER(15);
    ```
    
- 컬럼 삭제
    
    ```sql
    ALTER TABLE CUSTOMERS 
    DROP COLUMN GENDER;  -- GENDER 컬럼 삭제
    ```
    
- 컬럼명 변경
    
    ```sql
    ALTER TABLE CUSTOMERS 
    RENAME COLUMN PHONE TO CONTACT_NUMBER;
    ```
    
- 테이블명 변경

### DROP

객체 삭제

- 테이블 자체를 삭제

```sql
DROP TABLE CUSTOMERS;
```

### TRUNCATE

테이블 데이터 초기화

- 테이블은 유지, 안에 있는 데이터만 삭제

```sql
TRUNCATE TABLE CUSTOMERS;
```

## DML (Data Manipulation Language)

데이터 조작 - 삽입 수정 삭제

### **INSERT**

테이블에 데이터 삽입

```sql
-- 전체 열에 데이터를 삽입
INSERT INTO CUSTOMERS
VALUES (1, 'John', 'Doe', 'john.doe@example.com', '123-456-7890', '123 Main St', 'Los Angeles', 'CA', '90001', 'USA', SYSDATE, SYSDATE);

-- 특정 열에만 데이터를 삽입
INSERT INTO CUSTOMERS (CUSTOMER_ID, FIRST_NAME, LAST_NAME, EMAIL)
VALUES (2, 'Jane', 'Smith', 'jane.smith@example.com');

```

### **SELECT**

테이블에서 데이터 조회

```sql
-- 모든 데이터 조회
SELECT * FROM CUSTOMERS;

-- 특정 열만 조회
SELECT FIRST_NAME, LAST_NAME, EMAIL FROM CUSTOMERS;

-- 조건을 지정하여 조회
SELECT * FROM CUSTOMERS WHERE CITY = 'Los Angeles';

-- 데이터 정렬
SELECT * FROM CUSTOMERS ORDER BY LAST_NAME ASC;

```

### **UPDATE**

테이블의 데이터 수정

```sql
-- 특정 열 업데이트
UPDATE CUSTOMERS
SET EMAIL = 'new.email@example.com', PHONE = '987-654-3210'
WHERE CUSTOMER_ID = 1;

-- 모든 행의 특정 열 업데이트
UPDATE CUSTOMERS
SET CITY = 'San Francisco';

```

### **DELETE**

테이블에서 데이터 삭제

```sql
-- 특정 조건의 데이터 삭제
DELETE FROM CUSTOMERS
WHERE CUSTOMER_ID = 2;

-- 모든 데이터를 삭제 (테이블은 유지)
DELETE FROM CUSTOMERS;

```

truncate - 공간까지 삭제

- 빠름. 다 날림. where 안씀
    - rollback 못함

delete - 데이터만 삭제

---

### **주의사항**

변경 후 꼭 select 해보기!!!

- `INSERT`와 `UPDATE`는 잘못된 데이터를 입력하지 않도록 주의하세요.
- `DELETE`는 삭제된 데이터를 복구할 수 없으므로 반드시 조건을 확인하세요.
- 트랜잭션을 사용하는 경우 `COMMIT` 또는 `ROLLBACK`을 통해 변경 사항을 저장하거나 취소할 수 있습니다.

```sql
-- 변경 사항 저장
COMMIT;

-- 변경 사항 취소
ROLLBACK;

```

## DCL (Data Control Language)

데이터 접근 권한 제어

### GRANT

권한 부여

```sql
GRANT SELECT ON CUSTOMERS TO USER1;
```

### REVOKE

권한 회수

```sql
REVOKE SELECT ON CUSTOMERS FROM USER1;
```

## TCL (Transaction Control Language)

트랜잭션 관리

커밋롤백 안하면 내 세션 말고 다른 데서는 안보임

### COMMIT

트랜잭션 확정

### ROLLBACK

트랜잭션 취소

### SAVEPOINT

특정 지점 저장

# SELECT

`SELECT *COL_NAME* FROM *TABLE_NAME;`* 

```sql
SELECT * FROM EMPLOYEES;
SELECT NAME, SALARY FROM EMPLOYEES;

```

컬럼을 하나만 뽑든, 전체를 뽑든 블록 하나를 뽑아와야하는 건 똑같아서 속도(튜닝) 측면에서 동일.

## ALIAS

### COLUMN ALIAS

`SELECT *COL_NAME* (AS) *COLUMN_ALIAS* FROM *TABLE_NAME*;`

- 연산 결과에 의미를 부여
- 출력 결과 컬럼 이름을 변경해 가독성 높임
    - 한글로 붙일 수도 있음 `“*별칭*”`

```sql
- ALIAS
SELECT NAME AS EMPLOYEE_NAME,
SALARY AS MONTHLY_SALARY
FROM EMPLOYEES;
```

```sql
SELECT SALARY*12 AS ANNUAL_SALARY
FROM EMPLOYEES;
```

### TABLE ALIAS

`SELECT *COL_NAME* FROM *TABLE_NAME* *TABLE_ALIAS;*`

- 테이블 이름이 길거나 복잡할 때 간결하게
    - JOIN 쿼리에서 테이블 이름 축약해서 사용
    - 다른 테이블인데 이름 겹칠 때 주로 씀

```sql
-- TABLE ALIAS
SELECT EMPLOYEES.NAME, E.SALARY
FROM EMPLOYEES E;
---
ORA-00904: "EMPLOYEES"."NAME": 부적합한 식별자

https://docs.oracle.com/error-help/db/ora-00904/00904. 00000 -  "%s: invalid identifier"
*Cause:    The identifier or column name entered was invalid.
*Action:   Ensure the following
18행, 8열에서 오류 발생
```

- 별칭 만들어 놓고 원래 테이블 이름 쓰면 에러남

## NULL

== 값이 없음 == 비어있음 ≠ 0 || “”

ISNULL!!!!

- NULL 값은 비교연산 불가능
    - `WHERE SALARY = NULL` ⇒ 결과 안나옴.  NULL연산은 항상 FALSE
- 가로줄에서 NULL 연산하면 무조건 NULL
- 세로줄(컬럼끼리) 연산하는 경우 (SUM, AVERAGE) NULL이 있다면 해당 ROW는 제외하고 나머지만 연산
    - AVERAGE인 경우 분자, 분모 모두에서 제외됨!!!!!

# WHERE

조건 지정해서 필터링

- UPDATE, DELETE 에서는 필수!

```sql
SELECT NAME FROM EMPLOYEES WHERE SALARY > 50000;
SELECT * FROM EMPLOYEES WHERE DEPARTMENT_ID = 10;
```

## 비교연산자

### EQUALS `=`

### NOT EQUALS `<>`

== `!=`

### GREATER|LESS `>`, `<`

### `>=`, `<=`

## 논리연산자

AND가 OR보다 우선!

### `AND`

- 모든 조건이 TRUE

```sql
SELECT * FROM EMPLOYEES
WHERE DEPARTMENT_ID = 10 AND SALARY > 5000;
```

### `OR`

- 한 가지 조건만 TRUE여도

### `NOT`

- 조건 결과 반전 시킴
    - TRUE → FALSE
    - FALSE → TRUE

```sql
SELECT * FROM EMPLOYEES WHERE NOT SALARY > 5000;
SELECT * FROM EMPLOYEES WHERE SALARY <= 5000; -- SAME
```

## 특수연산자

### `LIKE`

특정 패턴을 가진 데이터 검색

- `%`: 0개 이상의 문자를 대체
- `_`: 1개의 문자를 대체

```sql
SELECT * FROM EMPLOYEES WHERE NAME LIKE '%1%';
```

### `ESCAPE`

Escape Character 설정 가능!

근데 아무거나로 설정 가능

`WHERE *COL_NAME* LIKE ‘*PATTERN*’ ESCAPE ‘*CHAR*’;`

- ESCAPE로 지정한 문자는 반드시 패턴 문자열에 포함되어야 함

```sql
SELECT * 
FROM FILES 
WHERE FILE_NAME LIKE 'DATA\_2024%' ESCAPE '\';
```

### `IN`

지정된 값 중 하나와 일치하는 데이터 찾기

- OR 조건으로 대체 가능
    - 둘이 실행계획? 똑같음
    - 그치만 OR. 예쁘지 않음.

```sql
SELECT * FROM EMPLOYEES
WHERE DEPARTMENT_ID IN (1, 2, 5);
```

```sql
SELECT * 
FROM EMPLOYEES
WHERE (MANAGER_ID, DEPARTMENT_ID) IN ((3, 5));
```

### `BETWEEN`

지정된 범위 내에 있는 값을 찾음

- 범위는 시작 값, 끝 값 포함

### `IS NULL`

NULL 값을 가진 데이터 찾음

- NOT을 붙이면 NULL 값이 아닌 데이터 찾음

```sql
SELECT * FROM EMPLOYEES WHERE MANAGER_ID IS NULL;
SELECT * FROM EMPLOYEES WHERE MANAGER_ID IS NOT NULL;
```

### 연산자 우선순위

- `()`
- 비교 연산자
- 💫`NOT`
- `AND`
- `OR`
