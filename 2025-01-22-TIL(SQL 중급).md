# 그룹 함수

데이터를 특정 기준으로 그룹핑하여 요약, 집계하는 데 사용

데이터 분석 및 보고서를 생성할 때 유용한 기술

다차원 데이터를 요약하는데 활용

### ROLLUP

<aside>
✨

롤업롤업

```sql
SELECT BRANCH_ID, STATUS, LOAN_ID, SUM(AMOUNT) AS AMOUNT
FROM LOANS
GROUP BY ROLLUP(BRANCH_ID, STATUS, LOAN_ID)
ORDER BY BRANCH_ID;
```

- **ROLLUP 결과 계층 구조**
    1. **BRANCH 1**
        - **STATUS 1**
            - 각 LOAN_ID의 AMOUNT
            - STATUS 1의 총 AMOUNT (**TOTAL_AMT**)
        - **STATUS 2**
            - 각 LOAN_ID의 AMOUNT
            - STATUS 2의 총 AMOUNT (**TOTAL_AMT**)
        - BRANCH 1의 총 AMOUNT (**TOTAL_AMT**)
    2. **BRANCH 2**
        - **STATUS 1**
            - 각 LOAN_ID의 AMOUNT
            - STATUS 1의 총 AMOUNT (**TOTAL_AMT**)
        - **STATUS 2**
            - 각 LOAN_ID의 AMOUNT
            - STATUS 2의 총 AMOUNT (**TOTAL_AMT**)
        - BRANCH 2의 총 AMOUNT (**TOTAL_AMT**)
    3. **GRAND_TOTAL**
        - 모든 BRANCH의 총 AMOUNT (**TOTAL_AMT**)

앞의 변수부터 차례로 요약해 전체 계층 구조를 표현

</aside>

특정 컬럼 순서대로 부분 합계 및 총합계를 계산하는 함수

- 소계와 총계를 한번에 생성하는 그룹 함수
- 지정된 컬럼 순서대로 그룹핑
- 컬럼 순서에 따라 결과 데이터가 달라짐
- 주로 보고서나 요약 데이터를 생성할 때 사용

```sql
SELECT JOB_ID, COUNT(*) AS CNT
FROM EMPLOYEES
GROUP BY JOB_ID
ORDER BY JOB_ID;

SELECT JOB_ID, COUNT(*) AS CNT
FROM EMPLOYEES
GROUP BY ROLLUP(JOB_ID)
ORDER BY JOB_ID;
```

```sql
SELECT JOB_ID, DEPARTMENT_ID, COUNT(*) AS CNT
FROM EMPLOYEES
WHERE DEPARTMENT_ID IS NOT NULL
GROUP BY ROLLUP(JOB_ID, DEPARTMENT_ID)
ORDER BY JOB_ID, DEPARTMENT_ID;

SELECT JOB_ID, DEPARTMENT_ID, COUNT(*) AS CNT
FROM EMPLOYEES
WHERE DEPARTMENT_ID IS NOT NULL
GROUP BY ROLLUP(DEPARTMENT_ID, JOB_ID)
ORDER BY JOB_ID, DEPARTMENT_ID;
```

### CUBE

<aside>
✨

`CUBE`는 **지정된 모든 그룹화 변수의 조합**에 대해 집계 결과를 생성

- **가능한 모든 부분 집합**

```sql
SELECT BRANCH_ID, STATUS, LOAN_ID, SUM(AMOUNT) AS AMOUNT
FROM LOANS
GROUP BY CUBE(BRANCH_ID, STATUS, LOAN_ID)
ORDER BY BRANCH_ID;
```

---

- **CUBE 결과 계층 구조**
    1. **BRANCH, STATUS, LOAN_ID**
        - 각 BRANCH, STATUS, LOAN_ID 조합의 세부 AMOUNT.
    2. **BRANCH, STATUS**
        - 특정 BRANCH와 STATUS의 총 AMOUNT (LOAN_ID 제외).
    3. **BRANCH, LOAN_ID**
        - 특정 BRANCH와 LOAN_ID의 총 AMOUNT (STATUS 제외).
    4. **STATUS, LOAN_ID**
        - 특정 STATUS와 LOAN_ID의 총 AMOUNT (BRANCH 제외).
    5. **BRANCH**
        - 특정 BRANCH의 총 AMOUNT (STATUS와 LOAN_ID 제외).
    6. **STATUS**
        - 특정 STATUS의 총 AMOUNT (BRANCH와 LOAN_ID 제외).
    7. **LOAN_ID**
        - 특정 LOAN_ID의 총 AMOUNT (BRANCH와 STATUS 제외).
    8. **GRAND_TOTAL**
        - 모든 데이터의 총 AMOUNT.

지정된 모든 그룹화 변수의 가능한 모든 조합에 대해 집계 결과

</aside>

모든 컬럼의 가능한 조합에 대해 다차원 집계를 계산하는 함수

- 롤업 확장판
- 소계와 총계를 한 번에 생성하는 그룹 함수
- 모든 가능한 조합에 대한 집계를 생성
- 컬럼 순서가 달라져도 결과 데이터는 동일
- 다차원 데이터 분석에 적합
- ROLLUP보다 더 많은 집계 결과를 생성

컬럼이 한 개면 ROLLUP이랑 결과 똑같음

```sql
SELECT JOB_ID, COUNT(*) AS CNT
FROM EMPLOYEES
GROUP BY CUBE(JOB_ID)
ORDER BY JOB_ID;
```

컬럼이 여러개라면

```sql
SELECT JOB_ID, DEPARTMENT_ID, COUNT(*) AS CNT
FROM EMPLOYEES
WHERE DEPARTMENT_ID IS NOT NULL
GROUP BY CUBE(DEPARTMENT_ID, JOB_ID)
ORDER BY JOB_ID, DEPARTMENT_ID;
```

ROLLUP에서 컬럼 순서 바꿔서 한 거 경우 다 나옴.

### GROUPING SETS

<aside>
✨

### **GROUPING SETS**

`GROUPING SETS`는 **명시적으로 지정한 그룹화 조합**에 대해 집계 결과

- `ROLLUP`이나 `CUBE`와 달리, 
**필요한 그룹화 조합만 선택적으로 정의**할 수 있음

---

```sql
SELECT BRANCH_ID, STATUS, LOAN_ID, SUM(AMOUNT) AS AMOUNT
FROM LOANS
GROUP BY GROUPING SETS (
    (BRANCH_ID, STATUS, LOAN_ID),
    (BRANCH_ID, STATUS),
    (BRANCH_ID),
    ()
)
ORDER BY BRANCH_ID;

```

---

- **GROUPING SETS 결과 계층 구조**
    1. **BRANCH, STATUS, LOAN_ID**
        - 각 BRANCH, STATUS, LOAN_ID 조합의 세부 AMOUNT.
    2. **BRANCH, STATUS**
        - 특정 BRANCH와 STATUS의 총 AMOUNT (LOAN_ID 제외).
    3. **BRANCH**
        - 특정 BRANCH의 총 AMOUNT (STATUS와 LOAN_ID 제외).
    4. **GRAND_TOTAL**
        - 모든 데이터의 총 AMOUNT.

"GROUPING SETS는 필요한 그룹화 조합을 명시적으로 정의하여 선택적인 집계 결과를 생성한다."

</aside>

뭔가 개별 기능 여러 개를 별도로 사용하고 싶을 때 쓰는 것 같음

지정된 그룹핑 조합에 대해서만 집계를 계산하는 함수

- 원하는 조합에 대해서만 집계 생성
- ROLLUP, CUBE보다 더 유연한 방식 제공
- 불필요한 집계 생성을 방지하여 성능 향상
- 서로 다른 기준으로 그룹핑 한 데이터 셋을 UNION ALL 한 결과와 동일한 데이터 출력

컬럼이 하나일때는 GROUP BY랑 똑같음

```sql
SELECT JOB_ID, COUNT(*) AS CNT
FROM EMPLOYEES
GROUP BY GROUPING SETS(JOB_ID)
ORDER BY JOB_ID
```

컬럼이 여러개일때는 UNION ALL이랑 똑같음

```sql
SELECT JOB_ID, DEPARTMENT_ID, COUNT(*) AS CNT
FROM EMPLOYEES
WHERE DEPARTMENT_ID IS NOT NULL
GROUP BY GROUPING SETS(JOB_ID, DEPARTMENT_ID)
ORDER BY JOB_ID, DEPARTMENT_ID;

-- UNION ALL ver.
SELECT JOB_ID, NULL, COUNT(*) AS CNT
FROM EMPLOYEES
WHERE DEPARTMENT_ID IS NOT NULL
GROUP BY JOB_ID
UNION ALL
SELECT NULL, DEPARTMENT_ID, COUNT(*) AS CNT
FROM EMPLOYEES
WHERE DEPARTMENT_ID IS NOT NULL
GROUP BY DEPARTMENT_ID;

---
SELECT JOB_ID, DEPARTMENT_ID, COUNT(*) AS CNT
FROM EMPLOYEES
WHERE DEPARTMENT_ID IS NOT NULL
GROUP BY GROUPING SETS(JOB_ID, DEPARTMENT_ID,())  -- 이렇게 하면 맨 아래에 토탈 나옴
ORDER BY JOB_ID, DEPARTMENT_ID; 
```

### GROUPING

집계 데이터와 실제 데이터를 구분하는데 사용하는 함수

```sql
SELECT JOB_ID, COUNT(*) AS CNT, GROUPING(JOB_ID)
FROM EMPLOYEES
GROUP BY ROLLUP(JOB_ID)
ORDER BY JOB_ID;

SELECT JOB_ID, DEPARTMENT_ID, COUNT(*) AS CNT,GROUPING(JOB_ID),GROUPING(DEPARTMENT_ID)
FROM EMPLOYEES
WHERE DEPARTMENT_ID IS NOT NULL
GROUP BY ROLLUP(JOB_ID, DEPARTMENT_ID)
ORDER BY JOB_ID, DEPARTMENT_ID;
```

```sql
SELECT CASE
        WHEN GROUPING(JOB_ID)=0 THEN JOB_ID
        WHEN GROUPING(JOB_ID)=1 THEN 'TOTAL'
        END JOB_ID, COUNT(*) AS CNT, GROUPING(JOB_ID)
FROM EMPLOYEES
GROUP BY ROLLUP(JOB_ID)
ORDER BY JOB_ID;
```

- 좀 정돈해서 예쁘게 뽑고 싶을 때
- 근데 NVL로 해도 됨..

# VIEW

SQL 쿼리 결과를 기반으로 만들어지는 가상 테이블

- 쿼리를 저장하는 오브젝트라고 보면 됨.
- 실제 데이터를 저장하지 않고 테이블처럼 동작
- 복잡한 쿼리를 단순화하여 사용자 접근성 향상
- 데이터 보안을 강화
    - 특정 열/행에 대한 접근 제한

### CREATE

```sql
CREATE VIEW view_name AS
	SELECT col1, col2 
	FROM table
	WHERE ;
```

사실 인라인 뷰랑 똑같음. 걍 대입 개념

### UPDATE

- 단일 테이블 기반 뷰
- PRIMARY KEY OR 고유 식별 컬럼 있어야함
- 뷰에 포함된 열이 기본 테이블의 실제 열이어야함
- GROUP BY, DISTINCT, 또는 집계 함수가 포함되지 않아야함
- 뷰에 있는 항목일 경우 원본 테이블이 바뀜

```sql
UPDATE EMPLOYEE_VIEW SET SALARY=6000 WHERE EMPLOYEE_ID = 100;
```

### DROP

`DROP VIEW view_name;`

## 단순 뷰(Simple View)

- 거의 없음

## 복합 뷰 (Complex View)

여러 테이블, 함수 또는 그룹화 포함

## 물리적 뷰 (Materialized View)

쿼리 결과를 물리적으로 저장하여 성능 향상

- 실제 데이터가 저장됨

```sql
CREATE MATERIALIZED VIEW JOB_SALARY_SUMMARY AS 
		SELECT JOB_ID, SUM(SALARY) AS TOTAL_SALARY
		FROM EMPLOYEES
		GROUP BY JOB_ID;
```

# Sequence

자동으로 고유한 숫자를 생성하는 오라클 객체

주로 기본키나 고유 값이 필요한 컬럼에 사용

- 고유한 숫자 생성 보장
- 숫자 증감 방향 설정 가능
- START WITH, INCREMENT BY 등으로 생성 규칙 정의 가능
- CACHE 사용해서 성능 최적화 가능

```sql
CREATE SEQUENCE sequence_name
	START WITH initial_value
	INCREMENT BY step_value
	MAXVALUE maximum_Ovalue
	CYCLE|NOCYCLE
	CACHE|NOCACHE;
```

```sql
CREATE SEQUENCE EMPLOYEE_SEQ
START WITH 1
INCREMENT BY 1
MAXVALUE 9999999
NOCACHE;
```

```sql
SELECT EMPLOYEE_SEQ.NEXTVAL FROM DUAL;
SELECT EMPLOYEE_SEQ.CURRVAL FROM DUAL;
```

```sql
INSERT INTO EMPLOYEES(EMPLOYEE_ID, NAME)
VALUES (EMPLOYEE_SEQ.NEXTVAL+1000, 'HIHI');
```

```sql
SELECT SEQUENCE_NAME, LAST_NUMBER
FROM USER_SEQUENCES;
```

```sql
DROP SEQUENCE EMPLOYEE_DEQ;
```
