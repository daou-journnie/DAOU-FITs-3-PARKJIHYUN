# 데이터베이스

### Data

현실세계에서 관찰하거나 측정하여 수집한 사실과 값

가공되지 않은 원천 정보

- 숫자, 문자, 기호

### Database

데이터를 체계적으로 저장, 관리, 검색하기 위한 시스템

- 정보의 집합
- 다양한 응용 프로그램이 데이터에 쉽게 접근하고 사용

## 종류

### RDBMS

데이터를 테이블 형식으로 저장

- ROW COLUMN
- 데이터 간 관계를 명확히 정의
    - 1:1, 1:N, N:M, 관계 명, 관계 선택사항

### NoSQL

### Cloud Database

### Distributed Database

OLTP: 실시간 데이터

## 구성요소

### 스키마

데이터베이스의 구조와 제약조건 정의

### 테이블

데이터를 저장하는 기본 단위

### 열

데이터 항목

### 행

데이터 속성

### 키

데이터 간 관계 정의

- FK
    
    다른 테이블의 PK를 참조하기 위한 키
    
    참조용으로만 생각하고 굳이 만들지는 않음
    

# 모델링

> 데이터를 구조화하여 현실 세계의 정보를 데이터베이스에 표현하는 과정
> 
- 비즈니스 요구사항을 기반으로 데이터의 구조와 관계를 설계하는 기술
- 데이터베이스 시스템의 효율성과 무결성을 확보하기 위한 핵심 단계

### Entity

데이터베이스에서 관리하려는 대상

### Attribute

엔티티의 세부 정보

### Relationship

엔티티 간 연결

### Key

데이터를 식별하거나 연결하기 위한 고유 값

- PK
    - 불변성 - 되도록 변하지 않는 값
    - 최소성 - 결합하여 식별자를 이룰 때 그 수가 최소가 되도록
    - Not Null
    - Unique
- FK
- UK
    - nullable
    - 한테이블에 여러개 가능

### Constraint

데이터 무결성을 유지하기 위한 규칙

UNIQUE, NOT NULL, CHECK

# ERD (Entity Relationship Diagram)

> 데이터베이스 설계의 기초가 되는 다이어그램
> 
- 데이터 구조 시각화
    - 시스템에서 관리해야 할 데이터 간의 관계를 시각적으로 표현
    - 데이터베이스 설계 전 시스템에서 관리할 데이터와 관계를 명확히 정의
- 문제점 사전 파악
    - 데이터 중복, 관계 오류 등 설계 단계에서 발생 가능한 문제를 조기에 발견 가능
- 팀 간 협업 촉진
    - 개발자, 기획자, 디비 관리자 간 공통 이해도구
    - 효율적 데이터베이스 설계
        - 정규화된 데이터 구조를 기반으로 효율적인 데이터 저장 및 관리 가능
- 엔터티, 속성, 관계 포함
- 데이터 모델링의 필수 도구

### Entity

데이터베이스에서 관리해야 할 개체

테이블로 구현

### Attribute

엔티티가 가지고 있는 정보

테이블 컬럼에 해당

### Relationship

엔티티 간의 연관성을 나타냄

관계형 데이터베이스에서 외래 키로 구현

### 주의 사항

- 데이터 중복 방지
- 정규화 적용
- 확장성 고려
- 다대다 관계 해결
    - 중간 엔터티(Bridge Table)를 도입하여 N:N 관계를 1:N 관계로 분리

### 다이어그램

| **Value (left)** | **Value (right)** | **Meaning** |
| --- | --- | --- |
| `|o` | `o|` | Zero or one |
| `||` | `||` | Exactly one |
| `}o` | `o{` | Zero or more (no upper limit) |
| `}|` | `|{` | One or more (no upper limit) |
- 엔티티
- 0개
    - 있을 수도 없을 수도. 옵션
- 1개
- 2개
- 주식별자
    
    자식 테이블의 주식별자가 부모 테이블의 주식별자를 포함
    
    부모가 삭제되면 자식도 삭제
    
    - 주문테이블
        - 주문(`ORDER`)은 고객(`CUSTOMER`)과 강하게 연결됩니다. 즉, 고객이 없으면 주문이 존재할 수 없습니다.
        - `ORDER` 테이블의 주식별자는 `customer_id`를 포함하여 생성됩니다.
    
    ```mermaid
    erDiagram
        CUSTOMER {
            int customer_id PK
            string name
            string email
        }
        ORDER {
            int customer_id PK
            int order_id PK
            date order_date
            float total_amount
        }
    
        CUSTOMER ||--|| ORDER : places
    
    ```
    
    - **`CUSTOMER` 테이블**
        - `customer_id`는 고객을 고유하게 식별하는 주식별자입니다.
        - 이름과 이메일은 일반 속성입니다.
    - **`ORDER` 테이블**
        - 주식별자는 복합키(`customer_id`, `order_id`)로 구성됩니다.
        - 즉, 특정 고객이 주문한 내역을 고유하게 식별할 수 있습니다.
        - `customer_id`는 부모 테이블(`CUSTOMER`)의 주식별자를 상속받아 포함됩니다.
    - **관계**
        - 한 고객은 반드시 0개 이상(`o{`)의 주문을 가질 수 있습니다.
        - 주문은 특정 고객에게 반드시 연결되어야 합니다(`||`).
- 비식별자
    
    자식 테이블이 부모 테이블의 주식별자를 자신의 주식별자로 포함하지 않고, 단순히 외래 키로만 참조하는 관계
    
    - 회원테이블 - 이벤트 테이블
        - 
        - 회원(`MEMBER`)은 이벤트(`EVENT`)에 참여할 수 있습니다.
        - `MEMBER_EVENT`는 회원과 이벤트 간의 연결 정보를 관리합니다.이 경우, `MEMBER_EVENT`의 주식별자는 독립적이며, `member_id`와 `event_id`는 단순 외래 키입니다
    
    ```mermaid
    erDiagram
        MEMBER {
            int member_id PK
            string name
            string email
        }
        EVENT {
            int event_id PK
            string event_name
            date event_date
        }
        MEMBER_EVENT {
            int member_event_id PK
            int member_id FK
            int event_id FK
        }
    
        MEMBER ||--o{ MEMBER_EVENT : participates_in
        EVENT ||--o{ MEMBER_EVENT : includes
    
    ```
    
    - **`MEMBER` 테이블**
        - `member_id`는 회원을 고유하게 식별하는 주식별자입니다.
        - 이름과 이메일은 일반 속성입니다.
    - **`EVENT` 테이블**
        - `event_id`는 이벤트를 고유하게 식별하는 주식별자입니다.
        - 이벤트 이름과 날짜는 일반 속성입니다.
    - **`MEMBER_EVENT` 테이블**
        - 주식별자는 `member_event_id`로, 독립적으로 고유한 값입니다.
        - `member_id`와 `event_id`는 각각 외래 키(FK)로 `MEMBER`와 `EVENT`를 참조합니다.
    - **관계**
        - 한 회원은 0개 이상의 이벤트에 참여할 수 있습니다.
        - 한 이벤트에는 0개 이상의 회원이 포함될 수 있습니다.

---

리뷰 조회 → 어떤 테이블의 리뷰인가? ⇒ 인덱스로 잡혀 있어야 조회 속도 빠름.

상품 코드 + sequence(리뷰 순번) ⇒ 상품 리뷰 구별

→ **이런 경우에 PK는 뭐가 되나용?? 어쨌든 리뷰별로 ID는 있으려나요?**

<aside>
✨

PK가 두 개 이상이 될 수 있나요?

---

💭 결합! PK는 하나의 컬럼 뿐만 아니라 두 개 이상도.. (A + 10001 → A10001)

⇒ 이것을 ‘**복합키**’라고 하나봅니다 👍

🤷‍♀️ 하나의 컬럼? Pk로 설정하는 건가요?

💭 같이 PK로 할거야 하면 DB가 알아서 해줘요. 근데 3,4개 이상이면 그냥 인조키를 만드는게 나아요

</aside>

<aside>
✨

컬럼에 JSON도 들어갈 수 있는 거 아셨나요?(NoSQL)

---

💭 family 컬럼 → 관계, 이름 등 항목등을 JSON 형태로 저장할 수 있음

이럴 경우, 속도가 빨라져요. 그래서 SNS에서도 쓰임

</aside>

